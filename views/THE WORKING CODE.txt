import sys
import cv2
import face_recognition
import numpy as np
from PyQt6 import QtWidgets, uic
from PyQt6.QtGui import QImage, QPixmap
from PyQt6.QtCore import Qt, QTimer
from PyQt6.QtWidgets import QDialog, QLabel, QHBoxLayout, QVBoxLayout, QListWidgetItem, QInputDialog

from controller.StudentController import StudentController
from controller.GuardianController import GuardianController
from os import path


# -----------------------------------------
# PATHS
# -----------------------------------------
BASE_DIR = path.dirname(path.abspath(__file__))
PROJECT_ROOT = path.abspath(path.join(BASE_DIR, ".."))
UI_FILE = path.join(PROJECT_ROOT, "ui", "scan.ui")

# class CameraCapture(QDialog):
#     def __init__(self):
#         super().__init__()
#         self.setWindowTitle("Scan Guardian Face")
#         self.resize(600, 500)

#         self.video_label = QLabel()
#         self.video_label.setFixedSize(560, 420)

#         self.capture_btn = QtWidgets.QPushButton("Capture")
#         self.capture_btn.clicked.connect(self.capture_frame)
        

#         layout = QVBoxLayout()
#         layout.addWidget(self.video_label)
#         layout.addWidget(self.capture_btn)
#         self.setLayout(layout)

#         self.cap = self.initialize_camera()
#         self.current_frame = None
#         self.last_face_location = None
#         self.motion_detected = False
#         self.captured_encoding = None

#         # FAST UI update (30 FPS)
#         self.render_timer = QTimer()
#         self.render_timer.timeout.connect(self.update_frame_fast)
#         self.render_timer.start(30)

#         # SLOW face detection (every 500ms)
#         self.detect_timer = QTimer()
#         self.detect_timer.timeout.connect(self.detect_face_motion)
#         self.detect_timer.start(500)
        
     
#     def cleanup_camera(self):
#         if hasattr(self, "render_timer"):
#             self.render_timer.stop()
#         if hasattr(self, "detect_timer"):
#             self.detect_timer.stop()
#         if hasattr(self, "cap") and self.cap:
#             self.cap.release()
#             self.cap = None
#         print("ðŸ“· Camera fully stopped!")

        
    
#     def initialize_camera(self):
#         """
#         Try different camera indexes with OS-appropriate backend.
#         """
#         import platform

#         system = platform.system()
#         possible_indexes = [0, 1, 2, 3]

#         for index in possible_indexes:
#             if system == "Windows":
#                 cap = cv2.VideoCapture(index, cv2.CAP_DSHOW)
#             elif system == "Darwin":  # macOS
#                 cap = cv2.VideoCapture(index, cv2.CAP_AVFOUNDATION)
#             else:  # Linux
#                 cap = cv2.VideoCapture(index)

#             cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
#             cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)

#             if cap.isOpened():
#                 ret, frame = cap.read()
#                 if ret:
#                     print(f"ðŸ“· Camera Activated â†’ index {index} | {system}")
#                     return cap

#             cap.release()

#         raise RuntimeError("No working camera found")

#     def update_frame(self):
#         ret, frame = self.cap.read()
#         if not ret:
#             return

#         rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
#         face_locations = face_recognition.face_locations(rgb)

#         # If face detected
#         if face_locations:
#             top, right, bottom, left = face_locations[0]
#             current_box = (top, right, bottom, left)

#             # Check motion
#             if self.last_face_location is not None:
#                 old_top, old_right, old_bottom, old_left = self.last_face_location

#                 # compute movement
#                 movement = abs(top - old_top) + abs(left - old_left)

#                 if movement > 25:  # movement threshold
#                     self.motion_detected = True

#             self.last_face_location = current_box

#         # display frame
#         h, w, ch = rgb.shape
#         qimg = QImage(rgb.data, w, h, ch * w, QImage.Format.Format_RGB888)
#         self.video_label.setPixmap(QPixmap.fromImage(qimg))

#         self.current_frame = frame

    
#     def update_frame_fast(self):
#         ret, frame = self.cap.read()
#         if not ret:
#             return

#         self.current_frame = frame

#         rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

#         h, w, ch = rgb.shape
#         qimg = QImage(rgb.data, w, h, ch * w, QImage.Format.Format_RGB888)
#         self.video_label.setPixmap(QPixmap.fromImage(qimg))

#     def detect_face_motion(self):
#         if self.current_frame is None:
#             return

#         # DOWN-SCALE for speed (2x faster)
#         small = cv2.resize(self.current_frame, (0,0), fx=0.5, fy=0.5)
#         rgb_small = cv2.cvtColor(small, cv2.COLOR_BGR2RGB)

#         face_locations = face_recognition.face_locations(rgb_small)

#         if not face_locations:
#             return

#         top, right, bottom, left = face_locations[0]

#         # rescale back to original size
#         top *= 2; right *= 2; bottom *= 2; left *= 2
#         current_box = (top, right, bottom, left)

#         if self.last_face_location is not None:
#             old_top, old_right, old_bottom, old_left = self.last_face_location
#             movement = abs(top - old_top) + abs(left - old_left)

#             if movement > 25:
#                 self.motion_detected = True

#         self.last_face_location = current_box

        
#     def capture_frame(self):
#         if not self.motion_detected:
#             QtWidgets.QMessageBox.warning(
#                 self, 
#                 "Anti-Spoofing", 
#                 "Please move your head slightly before the system can capture.\n"
#                 "(Prevents scanning printed photos)"
#             )
#             return

#         rgb = cv2.cvtColor(self.current_frame, cv2.COLOR_BGR2RGB)
#         faces = face_recognition.face_locations(rgb)

#         if not faces:
#             QtWidgets.QMessageBox.warning(self, "Error", "No face detected")
#             return

#         # self.captured_encoding = face_recognition.face_encodings(rgb, faces)[0]
#         # self.accept()
        
#         self.captured_encoding = face_recognition.face_encodings(rgb, faces)[0]
#         self.captured_image = rgb   # store image for preview
#         self.show_preview_dialog()


#     def closeEvent(self, event):
#         if self.cap:
#             self.cap.release()
#         if hasattr(self, "render_timer"):
#             self.render_timer.stop()
#         if hasattr(self, "detect_timer"):
#             self.detect_timer.stop()
#         event.accept()
        
#     def cancel_scan(self):
#         self.captured_encoding = None
#         self.cleanup_camera()
#         self.reject()   # returns DialogCode.Rejected


#     def show_preview_dialog(self):
#         preview = QDialog(self)
#         preview.setWindowTitle("Confirm Capture")
#         preview.resize(400, 450)

#         vbox = QVBoxLayout()

#         # Convert image for display
#         h, w, ch = self.captured_image.shape
#         qimg = QImage(self.captured_image.data, w, h, ch * w, QImage.Format.Format_RGB888)
#         pix = QPixmap.fromImage(qimg).scaled(350, 350, Qt.AspectRatioMode.KeepAspectRatio)

#         img_lbl = QLabel()
#         img_lbl.setPixmap(pix)
#         vbox.addWidget(img_lbl)

#         # Buttons
#         btn_confirm = QtWidgets.QPushButton("Confirm")
#         btn_cancel = QtWidgets.QPushButton("Cancel")

#         # btn_confirm.clicked.connect(lambda: (preview.accept(), self.accept()))
#         # btn_cancel.clicked.connect(lambda: (preview.reject(), self.reject()))
#         btn_cancel.clicked.connect(lambda: (self.cleanup_camera(), preview.reject(), self.reject()))
#         btn_confirm.clicked.connect(lambda: (self.cleanup_camera(), preview.accept(), self.accept()))


#         hbox = QtWidgets.QHBoxLayout()
#         hbox.addWidget(btn_confirm)
#         hbox.addWidget(btn_cancel)

#         vbox.addLayout(hbox)
#         preview.setLayout(vbox)

#         preview.exec()

# class CameraCapture(QDialog):
#     def __init__(self):
#         super().__init__()
#         self.setWindowTitle("Scan Guardian Face")
#         self.resize(600, 500)

#         self.video_label = QLabel()
#         self.video_label.setFixedSize(560, 420)

#         self.capture_btn = QtWidgets.QPushButton("Capture")
#         self.capture_btn.clicked.connect(self.capture_frame)

#         layout = QVBoxLayout()
#         layout.addWidget(self.video_label)
#         layout.addWidget(self.capture_btn)
#         self.setLayout(layout)

#         self.cap = self.initialize_camera()
#         self.current_frame = None
#         self.last_face_location = None
#         self.motion_detected = False
#         self.captured_encoding = None

#         # FAST UI update
#         self.render_timer = QTimer()
#         self.render_timer.timeout.connect(self.update_frame_fast)
#         self.render_timer.start(30)

#         # SLOW motion detection
#         self.detect_timer = QTimer()
#         self.detect_timer.timeout.connect(self.detect_face_motion)
#         self.detect_timer.start(500)

#     def cleanup_camera(self):
#         if hasattr(self, "render_timer"):
#             self.render_timer.stop()
#         if hasattr(self, "detect_timer"):
#             self.detect_timer.stop()
#         if hasattr(self, "cap") and self.cap:
#             self.cap.release()
#             self.cap = None

#     def initialize_camera(self):
#         import platform
#         system = platform.system()

#         for i in [0, 1, 2, 3]:
#             if system == "Windows":
#                 cap = cv2.VideoCapture(i, cv2.CAP_DSHOW)
#             elif system == "Darwin":
#                 cap = cv2.VideoCapture(i, cv2.CAP_AVFOUNDATION)
#             else:
#                 cap = cv2.VideoCapture(i)

#             cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
#             cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)

#             if cap.isOpened():
#                 ret, frame = cap.read()
#                 if ret:
#                     return cap
#             cap.release()

#         raise RuntimeError("No working camera found")

#     # def update_frame_fast(self):
#     #     ret, frame = self.cap.read()
#     #     if not ret:
#     #         return

#     #     self.current_frame = frame
#     #     rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

#     #     h, w, ch = rgb.shape
#     #     qimg = QImage(rgb.data, w, h, ch * w, QImage.Format.Format_RGB888)
#     #     self.video_label.setPixmap(QPixmap.fromImage(qimg))
    
#     def update_frame_fast(self):
#         ret, frame = self.cap.read()
#         if not ret:
#             return

#         # Mirror the camera so it looks natural
#         frame = cv2.flip(frame, 1)

#         self.current_frame = frame
#         rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

#         h, w, ch = rgb.shape
#         qimg = QImage(rgb.data, w, h, ch * w, QImage.Format.Format_RGB888)
#         self.video_label.setPixmap(QPixmap.fromImage(qimg))


#     def detect_face_motion(self):
#         if self.current_frame is None:
#             return

#         small = cv2.resize(self.current_frame, (0,0), fx=0.5, fy=0.5)
#         rgb_small = cv2.cvtColor(small, cv2.COLOR_BGR2RGB)

#         faces = face_recognition.face_locations(rgb_small, model="hog")
#         if not faces:
#             return

#         top, right, bottom, left = faces[0]
#         top *= 2; right *= 2; bottom *= 2; left *= 2

#         if self.last_face_location is not None:
#             old_top, old_right, old_bottom, old_left = self.last_face_location
#             movement = abs(top - old_top) + abs(left - old_left)
#             if movement > 25:
#                 self.motion_detected = True

#         self.last_face_location = (top, right, bottom, left)

#     def capture_frame(self):
#         if not self.motion_detected:
#             QtWidgets.QMessageBox.warning(
#                 self,
#                 "Anti-Spoofing",
#                 "Move your head slightly before capture."
#             )
#             return

#         rgb = cv2.cvtColor(self.current_frame, cv2.COLOR_BGR2RGB)
#         faces = face_recognition.face_locations(rgb, model="hog")

#         if not faces:
#             QtWidgets.QMessageBox.warning(self, "Error", "No face detected.")
#             return

#         # HIGH ACCURACY embedding (uses large model)
#         self.captured_encoding = face_recognition.face_encodings(
#             rgb, faces, model="large"
#         )[0]

#         self.captured_image = rgb
#         self.show_preview_dialog()

#     def show_preview_dialog(self):
#         preview = QDialog(self)
#         preview.setWindowTitle("Confirm Capture")
#         preview.resize(400, 450)

#         vbox = QVBoxLayout()

#         h, w, ch = self.captured_image.shape
#         qimg = QImage(self.captured_image.data, w, h, ch * w, QImage.Format.Format_RGB888)
#         pix = QPixmap.fromImage(qimg).scaled(350, 350, Qt.AspectRatioMode.KeepAspectRatio)

#         img_lbl = QLabel()
#         img_lbl.setPixmap(pix)
#         vbox.addWidget(img_lbl)

#         btn_confirm = QtWidgets.QPushButton("Confirm")
#         btn_cancel = QtWidgets.QPushButton("Cancel")

#         btn_confirm.clicked.connect(lambda: (self.cleanup_camera(), preview.accept(), self.accept()))
#         btn_cancel.clicked.connect(lambda: (self.cleanup_camera(), preview.reject(), self.reject()))

#         hbox = QHBoxLayout()
#         hbox.addWidget(btn_confirm)
#         hbox.addWidget(btn_cancel)

#         vbox.addLayout(hbox)
#         preview.setLayout(vbox)
#         preview.exec()

#     def closeEvent(self, event):
#         self.cleanup_camera()
#         event.accept()



class CameraCapture(QDialog):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Scanning...")
        self.resize(600, 500)

        self.video_label = QLabel()
        self.video_label.setFixedSize(560, 420)

        layout = QVBoxLayout()
        layout.addWidget(self.video_label)
        self.setLayout(layout)

        self.cap = self.initialize_camera()
        self.current_frame = None
        self.last_face_location = None
        self.motion_detected = False
        self.captured_encoding = None
        self.auto_captured = False

        # UI camera feed refresh
        self.render_timer = QTimer()
        self.render_timer.timeout.connect(self.update_frame_fast)
        self.render_timer.start(30)

        # Motion + face detection loop
        self.detect_timer = QTimer()
        self.detect_timer.timeout.connect(self.detect_face_and_capture)
        self.detect_timer.start(500)

    def initialize_camera(self):
        import platform
        system = platform.system()

        for i in [0, 1, 2, 3]:
            if system == "Windows":
                cap = cv2.VideoCapture(i, cv2.CAP_DSHOW)
            elif system == "Darwin":
                cap = cv2.VideoCapture(i, cv2.CAP_AVFOUNDATION)
            else:
                cap = cv2.VideoCapture(i)

            cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
            cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)

            if cap.isOpened():
                ret, frame = cap.read()
                if ret:
                    return cap
            cap.release()

        raise RuntimeError("No working camera found")

    def update_frame_fast(self):
        ret, frame = self.cap.read()
        if not ret:
            return
        
        frame = cv2.flip(frame, 1)
        self.current_frame = frame

        rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        h, w, ch = rgb.shape
        qimg = QImage(rgb.data, w, h, ch * w, QImage.Format.Format_RGB888)
        self.video_label.setPixmap(QPixmap.fromImage(qimg))

    def detect_face_and_capture(self):
        if self.auto_captured or self.current_frame is None:
            return

        small = cv2.resize(self.current_frame, (0,0), fx=0.5, fy=0.5)
        rgb_small = cv2.cvtColor(small, cv2.COLOR_BGR2RGB)

        faces = face_recognition.face_locations(rgb_small, model="hog")
        if not faces:
            return

        top, right, bottom, left = faces[0]
        top *= 2; right *= 2; bottom *= 2; left *= 2

        if self.last_face_location:
            old_top, old_right, old_bottom, old_left = self.last_face_location
            movement = abs(top - old_top) + abs(left - old_left)
            if movement > 25:
                self.motion_detected = True

        self.last_face_location = (top, right, bottom, left)

        # Proceed automatically when face moves
        if self.motion_detected:
            self.auto_captured = True
            self.capture_frame()

    def capture_frame(self):
        rgb = cv2.cvtColor(self.current_frame, cv2.COLOR_BGR2RGB)
        faces = face_recognition.face_locations(rgb, model="hog")

        if not faces:
            QtWidgets.QMessageBox.warning(self, "Error", "Face lost, try again.")
            self.auto_captured = False
            return

        self.captured_encoding = face_recognition.face_encodings(
            rgb, faces, model="large"
        )[0]

        self.cleanup_camera()
        self.accept()

    def cleanup_camera(self):
        if hasattr(self, "render_timer"):
            self.render_timer.stop()
        if hasattr(self, "detect_timer"):
            self.detect_timer.stop()
        if self.cap:
            self.cap.release()

    def closeEvent(self, event):
        self.cleanup_camera()
        event.accept()



# --------------------------------------------------------
# MAIN SCAN WINDOW
# --------------------------------------------------------
class ScanWindow(QtWidgets.QMainWindow):
    def __init__(self, username):
        super().__init__()

        self.username = username
        self.student_controller = StudentController()
        self.guardian_controller = GuardianController()

        # Load UI
        uic.loadUi(UI_FILE, self)
        
        
        
        self.resize(1400, 800)

        # --- center window ---
        screen = QtWidgets.QApplication.primaryScreen().availableGeometry()
        win = self.frameGeometry()
        win.moveCenter(screen.center())
        self.move(win.topLeft())
        
        self.studentList = self.findChild(QtWidgets.QListWidget)

        if self.studentList is None:
            print("ERROR: Could not find ANY QListWidget in UI.")
        else:
            print("LIST FOUND:", self.studentList.objectName())
            self.studentList.itemClicked.connect(self.handle_student_click)
    

        # ---------------------------
        # REQUIRED UI ELEMENTS
        # ---------------------------
        self.scanSearchField = self.findChild(QtWidgets.QLineEdit, "scanSearchField")
        self.studentList = self.findChild(QtWidgets.QListWidget, "listWidget")
        self.backBtn = self.findChild(QtWidgets.QPushButton, "backBtn")
        
        
        
        # --------------------------------------
        # HOVER EFFECT FOR STUDENT LIST
        # --------------------------------------
        self.studentList.setMouseTracking(True)
        self.studentList.setStyleSheet("""
            QListWidget::item {
                padding: 10px;
                color: #333;
            }
            QListWidget::item:hover {
                background: #f0e6ff;
                color: #8b2fdb;
            }
            QListWidget::item:selected {
                background: #8b2fdb;
                color: white;
            }
        """)

        print("UI LOADED â†’", self.scanSearchField, self.studentList, self.backBtn)

        # ---------------------------
        # CONNECT EVENTS
        # ---------------------------
        if self.scanSearchField:
            self.scanSearchField.textChanged.connect(self.refresh_student_list)

        if self.studentList:
            self.studentList.itemClicked.connect(self.handle_student_click)

        if self.backBtn:
            self.backBtn.clicked.connect(self.go_back)

        self.all_students = []
        self.refresh_student_list()

    # ----------------------------------------------------
    # LOAD + SEARCH STUDENTS
    # ----------------------------------------------------
    def refresh_student_list(self):
        term = self.scanSearchField.text().strip() if self.scanSearchField else ""
        students = self.student_controller.search_students(self.username, term)

        print("DEBUG students from search:", students)

        self.all_students = students
        self.studentList.clear()

        for s in students:
            fullname = f"{s['studlname']}, {s['studfname']} {s['studmname'] or ''}".strip()
            item = QListWidgetItem(f"{fullname} ({s['studid']})")
            item.setData(Qt.ItemDataRole.UserRole, s["studid"])
            self.studentList.addItem(item)

    # ----------------------------------------------------
    # ON STUDENT CLICK â†’ OPEN CAMERA
    # ----------------------------------------------------
    
    # def handle_student_click(self, item: QListWidgetItem):
    #     if item is None:
    #         return

    #     studid = item.data(Qt.ItemDataRole.UserRole)
    #     if not studid:
    #         QtWidgets.QMessageBox.warning(self, "Error", "Invalid student selected")
    #         return

    #     student = next((s for s in self.all_students if s["studid"] == studid), None)
    #     if student is None:
    #         QtWidgets.QMessageBox.warning(self, "Error", "Student not found")
    #         return

    #     fullname = f"{student['studlname']}, {student['studfname']} {student['studmname'] or ''}".strip()

    #     # Open camera dialog
    #     cam = CameraCapture()
    #     result = cam.exec()

    #     if result != QtWidgets.QDialog.DialogCode.Accepted:
    #         return

    #     captured = cam.captured_encoding
    #     if captured is None:
    #         QtWidgets.QMessageBox.warning(self, "Error", "No face captured")
    #         return

    #     # Load guardians for this student
    #     # Convert studid â†’ studentid (INT PK)
    #     student = self.student_controller.get_student(self.username, studid)
    #     if not student:
    #         QtWidgets.QMessageBox.warning(self, "Error", "Student not found")
    #         return

    #     real_id = student["studentid"]

    #     guardians = self.guardian_controller.get_guardians_for_student(real_id)

    #     if not guardians:
    #         QtWidgets.QMessageBox.warning(self, "No Guardians", "No guardians registered")
    #         return

    #     known_encodings = []
    #     names = []

    #     for g in guardians:
    #         enc_bytes = g.get("face_encoding")
    #         if enc_bytes:
    #             try:
    #                 decoded = self.guardian_controller.decode_face(enc_bytes)
    #                 if decoded is not None:
    #                     known_encodings.append(decoded)
    #                     names.append(g["guardianname"])
    #             except Exception as e:
    #                 print("Decode error:", e)

    #     if not known_encodings:
    #         QtWidgets.QMessageBox.warning(self, "Error", "No stored face encodings")
    #         return

    #     # STRICT FACE MATCH
    #     distances = face_recognition.face_distance(known_encodings, captured)
    #     best_idx = int(np.argmin(distances))
    #     best_distance = float(distances[best_idx])

    #     THRESHOLD = 0.42  # strict

    #     # ========== VERIFIED BRANCH ==========
    #     if best_distance <= THRESHOLD:
    #         guardian_name = names[best_idx]

    #         status = self.guardian_controller.get_today_attendance(studid)

    #         # No attendance yet â†’ DROP-OFF
    #         if status is None or status["dropoff_time"] is None:
    #             self.guardian_controller.call_dropoff(studid, guardian_name, True)
    #             QtWidgets.QMessageBox.information(
    #                 self,
    #                 "Drop-off Recorded",
    #                 f"Student: {fullname}\nGuardian: {guardian_name}\nStatus: DROP-OFF"
    #             )
    #             return

    #         # Drop-off exists, but no pickup â†’ PICK-UP
    #         if status["pickup_time"] is None:
    #             self.guardian_controller.call_pickup(studid, guardian_name, True)
    #             QtWidgets.QMessageBox.information(
    #                 self,
    #                 "Pick-up Recorded",
    #                 f"Student: {fullname}\nGuardian: {guardian_name}\nStatus: PICK-UP"
    #             )
    #             return

    #         # Both already recorded
    #         QtWidgets.QMessageBox.warning(
    #             self,
    #             "Already Completed",
    #             f"Student: {fullname}\nBoth DROP-OFF and PICK-UP are already recorded today."
    #         )
    #         return

    #     # ========== UNVERIFIED BRANCH ==========
    #     emergency_contact = student.get("studcontact") or "No contact number stored"

    #     # Record attendance FIRST with UNVERIFIED GUARDIAN
    #     status = self.guardian_controller.get_today_attendance(studid)

    #     if status is None or status["dropoff_time"] is None:
    #         # No attendance yet â†’ DROP-OFF
    #         self.guardian_controller.call_dropoff(studid, "UNVERIFIED GUARDIAN", False)
    #         action = "DROP-OFF"
    #     elif status["pickup_time"] is None:
    #         # Dropoff exists, no pickup â†’ PICK-UP
    #         self.guardian_controller.call_pickup(studid, "UNVERIFIED GUARDIAN", False)
    #         action = "PICK-UP"
    #     else:
    #         # Both already done
    #         QtWidgets.QMessageBox.warning(
    #             self,
    #             "Already Completed",
    #             f"Student: {fullname}\nBoth DROP-OFF and PICK-UP are already recorded today."
    #         )
    #         return

    #     # Show info + emergency contact + manual option
    #     msg = QtWidgets.QMessageBox()
    #     msg.setWindowTitle("Guardian NOT Recognized")
    #     msg.setIcon(QtWidgets.QMessageBox.Icon.Warning)
    #     msg.setText(
    #         f"Student: {fullname}\n"
    #         f"âš  Guardian NOT recognized.\n\n"
    #         f"Attendance Recorded: {action} (UNVERIFIED GUARDIAN)\n"
    #         f"ðŸ“ž Emergency Contact: {emergency_contact}\n\n"
    #         f"You may add the guardian name now or later."
    #     )

    #     manual_btn = msg.addButton("Add Guardian Name Now", QtWidgets.QMessageBox.ButtonRole.AcceptRole)
    #     skip_btn = msg.addButton("Skip For Now", QtWidgets.QMessageBox.ButtonRole.RejectRole)
    #     msg.exec()

    #     if msg.clickedButton() == manual_btn:
    #         name, ok = QInputDialog.getText(
    #             self,
    #             "Manual Verification",
    #             "Enter Guardian Name:"
    #         )
    #         if ok and name.strip():
    #             manual_name = name.strip()
    #             # FIX: only update pickup guardian, NOT dropoff guardian
    #             self.guardian_controller.update_pickup_guardian(studid, manual_name)


    #             QtWidgets.QMessageBox.information(
    #                 self,
    #                 "Guardian Updated",
    #                 f"Manual verification recorded:\nGuardian: {manual_name}"
    #             )


    def handle_student_click(self, item: QListWidgetItem):
        if item is None:
            return

        # ----------------------------------------------------
        # GET STUDENT BY CODE (studid like "S001")
        # ----------------------------------------------------
        studid = item.data(Qt.ItemDataRole.UserRole)
        if not studid:
            QtWidgets.QMessageBox.warning(self, "Error", "Invalid student selected")
            return

        student = next((s for s in self.all_students if s["studid"] == studid), None)
        if student is None:
            QtWidgets.QMessageBox.warning(self, "Error", "Student not found")
            return

        fullname = f"{student['studlname']}, {student['studfname']} {student['studmname'] or ''}".strip()

        # ----------------------------------------------------
        # OPEN CAMERA + CAPTURE FACE
        # ----------------------------------------------------
        cam = CameraCapture()
        result = cam.exec()

        if result != QtWidgets.QDialog.DialogCode.Accepted:
            return

        captured = cam.captured_encoding
        frame = cam.current_frame

        if captured is None:
            QtWidgets.QMessageBox.warning(self, "Error", "No face captured")
            return

        # ----------------------------------------------------
        # SECURITY CHECK: FACE SIZE MUST BE LARGE ENOUGH
        # ----------------------------------------------------
        rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        faces = face_recognition.face_locations(rgb)

        if not faces:
            QtWidgets.QMessageBox.warning(self, "Error", "No face detected")
            return

        top, right, bottom, left = faces[0]
        face_width = right - left
        face_height = bottom - top

        # Prevent scanning small printed photos or far faces
        if face_width < 150 or face_height < 150:
            QtWidgets.QMessageBox.warning(
                self,
                "Too Far",
                "Please move closer to the camera."
            )
            return

        # ----------------------------------------------------
        # GET REAL studentid (INT PK)
        # ----------------------------------------------------
        student_db = self.student_controller.get_student(self.username, studid)
        if not student_db:
            QtWidgets.QMessageBox.warning(self, "Error", "Student not found in DB")
            return

        real_id = student_db["studentid"]   # <--- correct primary key

        # ----------------------------------------------------
        # LOAD GUARDIANS (STUDENT-SPECIFIC)
        # ----------------------------------------------------
        guardians = self.guardian_controller.get_guardians_for_student(real_id)

        if not guardians:
            QtWidgets.QMessageBox.warning(self, "No Guardians", "No guardians registered")
            return

        # Convert bytea â†’ numpy arrays
        known_encodings = []
        names = []

        for g in guardians:
            enc_bytes = g.get("face_encoding")
            if enc_bytes:
                try:
                    decoded = self.guardian_controller.decode_face(enc_bytes)
                    if decoded is not None:
                        known_encodings.append(decoded)
                        names.append(g["guardianname"])
                except Exception as e:
                    print("Decode error:", e)

        if not known_encodings:
            QtWidgets.QMessageBox.warning(self, "Error", "No stored face encodings")
            return

        # ----------------------------------------------------
        # FACE RECOGNITION MATCHING
        # ----------------------------------------------------
        # distances = face_recognition.face_distance(known_encodings, captured)
        # best_idx = int(np.argmin(distances))
        # best_distance = float(distances[best_idx])

        # THRESHOLD = 0.42  # child-safety strict threshold

        # # ----------------------------------------------------
        # # ========== VERIFIED BRANCH ==========
        # # ----------------------------------------------------
        # if best_distance <= THRESHOLD:
        #     guardian_name = names[best_idx]

        #     status = self.guardian_controller.get_today_attendance(real_id)

        #     # NO dropoff yet â†’ DROP OFF
        #     if status is None or status["dropoff_time"] is None:
        #         self.guardian_controller.call_dropoff(real_id, guardian_name, True)
        #         QtWidgets.QMessageBox.information(
        #             self,
        #             "Drop-off Recorded",
        #             f"Student: {fullname}\nGuardian: {guardian_name}\nStatus: DROP-OFF"
        #         )
        #         return

        #     # Dropoff exists but NO pickup â†’ PICK UP
        #     if status["pickup_time"] is None:
        #         self.guardian_controller.call_pickup(real_id, guardian_name, True)
        #         QtWidgets.QMessageBox.information(
        #             self,
        #             "Pick-up Recorded",
        #             f"Student: {fullname}\nGuardian: {guardian_name}\nStatus: PICK-UP"
        #         )
        #         return

        #     # Both completed
        #     QtWidgets.QMessageBox.warning(
        #         self,
        #         "Already Completed",
        #         f"Student: {fullname}\nBoth DROP-OFF and PICK-UP are already recorded today."
        #     )
        #     return
        
        distances = face_recognition.face_distance(known_encodings, captured)
        best_idx = int(np.argmin(distances))
        best_distance = float(distances[best_idx])

        THRESHOLD = 0.40  # strict + makeup-friendly

        if best_distance <= THRESHOLD:
            guardian_name = names[best_idx]
            status = self.guardian_controller.get_today_attendance(real_id)

            if status is None or status["dropoff_time"] is None:
                self.guardian_controller.call_dropoff(real_id, guardian_name, True)
                QtWidgets.QMessageBox.information(self, "Drop-off Recorded",
                    f"Student: {fullname}\nStudent Status: Attendance Recorded\nGuardian: {guardian_name}\nAction: DROP-OFF")
                return

            if status["pickup_time"] is None:
                self.guardian_controller.call_pickup(real_id, guardian_name, True)
                QtWidgets.QMessageBox.information(self, "Pick-up Recorded",
                    f"Student: {fullname}\nStudent Status: Attendance Recorded\nGuardian: {guardian_name}\nAction: PICK-UP")
                return

            QtWidgets.QMessageBox.warning(self, "Already Completed",
                f"Student: {fullname}\nBoth DROP-OFF and PICK-UP already recorded today.")
            return


        # ----------------------------------------------------
        # ========== UNVERIFIED BRANCH ==========
        # ----------------------------------------------------
        emergency_contact = student.get("studcontact") or "No contact number stored"

        status = self.guardian_controller.get_today_attendance(real_id)

        if status is None or status["dropoff_time"] is None:
            # First log â†’ DROP-OFF
            self.guardian_controller.call_dropoff(real_id, "UNVERIFIED GUARDIAN", False)
            action = "DROP-OFF"
        elif status["pickup_time"] is None:
            # Follow-up log â†’ PICK-UP
            self.guardian_controller.call_pickup(real_id, "UNVERIFIED GUARDIAN", False)
            action = "PICK-UP"
        else:
            QtWidgets.QMessageBox.warning(
                self,
                "Already Completed",
                f"Student: {fullname}\nBoth DROP-OFF and PICK-UP are already recorded today."
            )
            return

        # ----------------------------------------------------
        # MANUAL GUARDIAN OVERRIDE (Emergency)
        # ----------------------------------------------------
        # msg = QtWidgets.QMessageBox()
        # msg.setWindowTitle("Guardian NOT Recognized")
        # msg.setIcon(QtWidgets.QMessageBox.Icon.Warning)
        # msg.setText(
        #     f"Guardian NOT recognized.\n\n"
        #     f"Attendance Recorded: {action} (UNVERIFIED GUARDIAN)\n\n"
        #     f"Student: {fullname}\n\n"
        #     f"Emergency Contact: {emergency_contact}\n\n"
        #     f"You may add the guardian name now or later."
        # )
        
    
        # manual_btn = msg.addButton("Add Guardian Name Now", QtWidgets.QMessageBox.ButtonRole.AcceptRole)
        # skip_btn = msg.addButton("Skip For Now", QtWidgets.QMessageBox.ButtonRole.RejectRole)
        # msg.exec()

        # ----------------------------------------------------
        # MANUAL GUARDIAN OVERRIDE (Emergency)
        # ----------------------------------------------------
        msg = QtWidgets.QMessageBox(self)
        msg.setWindowTitle("Guardian NOT Recognized")
        msg.setIcon(QtWidgets.QMessageBox.Icon.Warning)

        msg.setTextFormat(Qt.TextFormat.RichText)

        msg.setText(
            f"""
            <div style="text-align:center;">

                <!-- Title -->
                <p style="font-size:18px; font-weight:700; margin-bottom:2px;">
                    Guardian NOT Recognized
                </p>

                <!-- Action -->
                <p style="font-size:14px; margin-top:0;">
                    for <b style="color:#8b2fdb;">{action}</b>
                </p>

                <!-- Big Spacer -->
                <div style="margin:18px 0;"></div>

                <!-- Contact -->
                <p style="font-size:14px; margin:4px 0;">
                    <b>You may add or contact guardian to verify:</b>
                </p>

                <p style="font-size:16px; font-weight:600; color:#8b2fdb; margin-top:2px;">
                    {emergency_contact}
                </p>

                <!-- Big Spacer -->
                <div style="margin:18px 0;"></div>

                <!-- Student Info -->
                <p style="text-align:left; margin-left:40px;">
                    <b>Student:</b> {fullname}<br>
                    <b>Status:</b> Attendance Recorded
                </p>

            </div>
            """
        )

        # Purple button design
        msg.setStyleSheet("""
            QMessageBox {
                background-color: #ffffff;
            }
            QLabel {
                color: #333;
                font-size: 13px;
            }
            QPushButton {
                min-width: 130px;
                padding: 7px 14px;
                border-radius: 8px;
                border: none;
                font-weight: 600;
                background-color: #8b2fdb;
                color: #ffffff;
            }
            QPushButton:hover {
                background-color: #a35cff;
            }
        """)

        manual_btn = msg.addButton("Add Guardian Name", QtWidgets.QMessageBox.ButtonRole.AcceptRole)
        skip_btn   = msg.addButton("Skip For Now", QtWidgets.QMessageBox.ButtonRole.RejectRole)

        msg.exec()

        # Optional: use your app logo as window icon
        # icon_path = path.join(PROJECT_ROOT, "assets", "images", "appLogo.png")
        # msg.setWindowIcon(QtGui.QIcon(icon_path))



        if msg.clickedButton() == manual_btn:
            name, ok = QInputDialog.getText(
                self,
                "Manual Verification",
                "Enter Guardian Name:"
            )

            if ok and name.strip():
                manual_name = name.strip()

                # Only update pickup guardian
                # self.guardian_controller.update_pickup_guardian(real_id, manual_name)
                # self.guardian_controller.manual_pickup(real_id, manual_name)
                if action == "DROP-OFF":
                    # DO NOT update time again â€” only correct the guardian name
                    self.guardian_controller.update_dropoff_guardian(real_id, manual_name)
                else:
                    # PICKUP truly needs a timestamp
                    self.guardian_controller.manual_pickup(real_id, manual_name)



                QtWidgets.QMessageBox.information(
                    self,
                    "Guardian Updated",
                    f"Manual verification recorded:\nGuardian: {manual_name}"
                )


    # ----------------------------------------------------
    # BACK TO CHOOSE MODE
    # ----------------------------------------------------
    def go_back(self):
        from views.mode import ChooseModeWindow
        self.mode = ChooseModeWindow(self.username)
        self.mode.show()
        self.close()





















signup:
    
    
    
# import sys
# from os import path
# from PyQt6 import QtWidgets, uic
# from PyQt6.QtGui import QPixmap
# from PyQt6.QtCore import Qt

# from controller.SignUpController import SignupController   # your controller file
# from utils.password_validator import validate_password     # password rules

# BASE_DIR = path.dirname(path.abspath(__file__))
# PROJECT_ROOT = path.abspath(path.join(BASE_DIR, ".."))

# UI_FILE = path.join(PROJECT_ROOT, "ui", "signup.ui")
# LOGO_FILE = path.join(PROJECT_ROOT, "assets", "images", "appLogo.png")
# BG_FILE   = path.join(PROJECT_ROOT, "assets", "images", "bg1.png")


# class SignupWindow(QtWidgets.QMainWindow):
#     def __init__(self):
#         super().__init__()

#         # Load UI into QMainWindow
#         uic.loadUi(UI_FILE, self)

#         # ---------- STACKED WIDGET NAVIGATION (OLD BEHAVIOR) ----------
#         try:
#             self.stacked = self.findChild(QtWidgets.QStackedWidget, "stackedWidget")
#             self.signUpPage = self.findChild(QtWidgets.QWidget, "signUpPage")
#             self.securityPage = self.findChild(QtWidgets.QWidget, "securityPage")

#             if self.stacked and self.signUpPage:
#                 self.stacked.setCurrentWidget(self.signUpPage)

#             self.nextBtn = self.findChild(QtWidgets.QPushButton, "nextBtn")
#             self.backToLoginBtn = self.findChild(QtWidgets.QPushButton, "backToLoginBtn")
#             self.backToSignupBtn = self.findChild(QtWidgets.QPushButton, "backToSignupBtn")
#             self.signupBtn = self.findChild(QtWidgets.QPushButton, "signupBtn")

#             if self.nextBtn and self.securityPage:
#                 self.nextBtn.clicked.connect(
#                     lambda: self.stacked.setCurrentWidget(self.securityPage)
#                 )
#             if self.backToSignupBtn and self.signUpPage:
#                 self.backToSignupBtn.clicked.connect(
#                     lambda: self.stacked.setCurrentWidget(self.signUpPage)
#                 )
#         except Exception:
#             # if stacked widget or buttons not found, silently ignore
#             pass

#         # ---------- BACKGROUND + FRAMES + LOGO (OLD UI LOOK) ----------
#         cw = self.findChild(QtWidgets.QWidget, "centralwidget")

#         self._bg_label = QtWidgets.QLabel(cw)
#         self._bg_pix = QPixmap(BG_FILE)
#         self._bg_label.setPixmap(self._bg_pix)
#         self._bg_label.setScaledContents(False)
#         self._bg_label.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
#         self._bg_label.lower()
#         self._bg_label.resize(cw.size())

#         right = self.findChild(QtWidgets.QFrame, "rightFrame")
#         if right:
#             right.setStyleSheet("background: transparent; border: none;")
#             right.setAutoFillBackground(False)

#         left = self.findChild(QtWidgets.QFrame, "leftFrame")
#         if left:
#             left.setStyleSheet("background: transparent; border: none;")
#             left.setAutoFillBackground(False)

#         self.logo_label = self.findChild(QtWidgets.QLabel, "logoLabel")
#         self._orig_logo_pix = QPixmap(LOGO_FILE)
#         if self.logo_label and not self._orig_logo_pix.isNull():
#             self.logo_label.setScaledContents(False)
#             self.logo_label.setStyleSheet("background: transparent;")
#             self.logo_label.setPixmap(self._orig_logo_pix)

#         self.setWindowTitle("EntrySafe - Sign Up")

#         # logo scaling settings
#         self.MAX_PROP = 0.40
#         self.ABS_MAX_W = 800
#         self.ABS_MIN_W = 120

#         # ---------- NEW BACKEND FIELDS ----------
#         self.userInput      = self.findChild(QtWidgets.QLineEdit, "userInput")
#         self.passInput      = self.findChild(QtWidgets.QLineEdit, "passInput")
#         self.homepassInput  = self.findChild(QtWidgets.QLineEdit, "homepassInput")

#         self.q1Input   = self.findChild(QtWidgets.QComboBox, "q1Input")
#         self.ans1Input = self.findChild(QtWidgets.QLineEdit, "ans1Input")
#         self.q2Input   = self.findChild(QtWidgets.QComboBox, "q2Input")
#         self.ans2Input = self.findChild(QtWidgets.QLineEdit, "ans2Input")

#         # backToLoginBtn & signupBtn were already found above
#         self.controller = SignupController()

#         if self.signupBtn:
#             self.signupBtn.clicked.connect(self.create_account)
#         if self.backToLoginBtn:
#             self.backToLoginBtn.clicked.connect(self.go_back)

#         # remove duplicate question in q2 when q1 changes
#         if self.q1Input:
#             self.q1Input.currentIndexChanged.connect(self.sync_questions)


#     # ---------- RESIZE BEHAVIOR (OLD) ----------
#     def resizeEvent(self, event):
#         super().resizeEvent(event)

#         cw = self.findChild(QtWidgets.QWidget, "centralwidget")
#         if cw and not self._bg_pix.isNull():
#             scaled_bg = self._bg_pix.scaled(
#                 cw.size(),
#                 Qt.AspectRatioMode.KeepAspectRatioByExpanding,
#                 Qt.TransformationMode.SmoothTransformation
#             )
#             self._bg_label.setPixmap(scaled_bg)
#             self._bg_label.resize(cw.size())
#             self._bg_label.move(0, 0)

#         if not self._orig_logo_pix.isNull() and self.logo_label:
#             target_w = int(self.width() * self.MAX_PROP)
#             target_w = max(self.ABS_MIN_W, min(target_w, self.ABS_MAX_W))

#             scaled_logo = self._orig_logo_pix.scaled(
#                 target_w, target_w,
#                 Qt.AspectRatioMode.KeepAspectRatio,
#                 Qt.TransformationMode.SmoothTransformation
#             )
#             self.logo_label.setPixmap(scaled_logo)

#     # ---------- SECURITY QUESTION LOGIC ----------
#     def sync_questions(self):
#         if not self.q1Input or not self.q2Input:
#             return

#         chosen = self.q1Input.currentText()
#         self.q2Input.clear()

#         all_questions = [
#             "What is your childhood nickname?",
#             "What is the name of your first pet?",
#             "What is the name of your first best friend?",
#             "What city were you born in?",
#             "What was the name of your first school?",
#             "What was the name of your favorite teacher?",
#             "What is your favorite food?",
#             "What is your favorite movie?"
#         ]

#         for q in all_questions:
#             if q != chosen:
#                 self.q2Input.addItem(q)

#     # ---------- SIGNUP BACKEND ----------
#     def create_account(self):
#         username = self.userInput.text().strip() if self.userInput else ""
#         password = self.passInput.text().strip() if self.passInput else ""
#         homepass = self.homepassInput.text().strip() if self.homepassInput else ""

#         q1 = self.q1Input.currentText() if self.q1Input else ""
#         a1 = self.ans1Input.text().strip() if self.ans1Input else ""
#         q2 = self.q2Input.currentText() if self.q2Input else ""
#         a2 = self.ans2Input.text().strip() if self.ans2Input else ""

#         if not username or not password or not a1 or not a2:
#             QtWidgets.QMessageBox.warning(self, "Missing Data", "Please fill in all required fields.")
#             return

#         ok, msg = validate_password(password)
#         if not ok:
#             QtWidgets.QMessageBox.warning(self, "Invalid Password", msg)
#             return

#         success, message = self.controller.signup(
#             username, password, homepass, q1, a1, q2, a2
#         )

#         if not success:
#             QtWidgets.QMessageBox.warning(self, "Signup Failed", message)
#             return

#         QtWidgets.QMessageBox.information(self, "Success", message)
#         self.go_back()

#     def go_back(self):
#         from views.login import LoginWindow   # import here to avoid circular import
#         self.close()
#         self.login = LoginWindow()
#         self.login.show()


import sys
import re
from os import path
from PyQt6 import QtWidgets, uic
from PyQt6.QtGui import QPixmap
from PyQt6.QtCore import Qt

from controller.SignUpController import SignupController
from utils.password_validator import validate_password

BASE_DIR = path.dirname(path.abspath(__file__))
PROJECT_ROOT = path.abspath(path.join(BASE_DIR, ".."))

UI_FILE = path.join(PROJECT_ROOT, "ui", "signup.ui")
LOGO_FILE = path.join(PROJECT_ROOT, "assets", "images", "appLogo.png")
BG_FILE = path.join(PROJECT_ROOT, "assets", "images", "bg1.png")


class SignupWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()

        # Load UI
        uic.loadUi(UI_FILE, self)
        
        
        self.resize(1250, 800)

        # --- center window ---
        screen = QtWidgets.QApplication.primaryScreen().availableGeometry()
        win = self.frameGeometry()
        win.moveCenter(screen.center())
        self.move(win.topLeft())

        # ------------ STACKED WIDGET (Next â†” Back pages) ------------
        try:
            self.stacked = self.findChild(QtWidgets.QStackedWidget, "stackedWidget")
            self.signUpPage = self.findChild(QtWidgets.QWidget, "signUpPage")
            self.securityPage = self.findChild(QtWidgets.QWidget, "securityPage")

            if self.stacked and self.signUpPage:
                self.stacked.setCurrentWidget(self.signUpPage)

            self.nextBtn = self.findChild(QtWidgets.QPushButton, "nextBtn")
            self.backToSignupBtn = self.findChild(QtWidgets.QPushButton, "backToSignupBtn")
            self.backToLoginBtn = self.findChild(QtWidgets.QPushButton, "backToLoginBtn")
            self.signupBtn = self.findChild(QtWidgets.QPushButton, "signupBtn")

            # if self.nextBtn and self.securityPage:
            #     self.nextBtn.clicked.connect(lambda: self.stacked.setCurrentWidget(self.securityPage))

            if self.nextBtn:
                self.nextBtn.clicked.connect(self.validate_step1)

            if self.backToSignupBtn and self.signUpPage:
                self.backToSignupBtn.clicked.connect(lambda: self.stacked.setCurrentWidget(self.signUpPage))

        except Exception:
            pass  # ignore if no stacked widget


        # ------------ BACKGROUND + TRANSPARENCY + LOGO (OLD UI LOOK) ------------
        cw = self.findChild(QtWidgets.QWidget, "centralwidget")

        self._bg_label = QtWidgets.QLabel(cw)
        self._bg_pix = QPixmap(BG_FILE)
        self._bg_label.setPixmap(self._bg_pix)
        self._bg_label.setScaledContents(False)
        self._bg_label.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
        self._bg_label.lower()
        self._bg_label.resize(cw.size())

        right = self.findChild(QtWidgets.QFrame, "rightFrame")
        if right:
            right.setStyleSheet("background: transparent; border: none;")
            right.setAutoFillBackground(False)

        left = self.findChild(QtWidgets.QFrame, "leftFrame")
        if left:
            left.setStyleSheet("background: transparent; border: none;")
            left.setAutoFillBackground(False)

        self.logo_label = self.findChild(QtWidgets.QLabel, "logoLabel")
        self._orig_logo_pix = QPixmap(LOGO_FILE)
        if self.logo_label and not self._orig_logo_pix.isNull():
            self.logo_label.setScaledContents(False)
            self.logo_label.setStyleSheet("background: transparent;")
            self.logo_label.setPixmap(self._orig_logo_pix)

        self.setWindowTitle("EntrySafe - Sign Up")

        # Logo scaling limits
        self.MAX_PROP = 0.40
        self.ABS_MAX_W = 800
        self.ABS_MIN_W = 120


        # ------------ FIELD CONNECTIONS (NEW BACKEND) ------------
        self.userInput      = self.findChild(QtWidgets.QLineEdit, "userInput")
        self.passInput      = self.findChild(QtWidgets.QLineEdit, "passInput")
        self.homepassInput  = self.findChild(QtWidgets.QLineEdit, "homepassInput")

        self.q1Input        = self.findChild(QtWidgets.QComboBox, "q1Input")
        self.ans1Input      = self.findChild(QtWidgets.QLineEdit, "ans1Input")
        self.q2Input        = self.findChild(QtWidgets.QComboBox, "q2Input")
        self.ans2Input      = self.findChild(QtWidgets.QLineEdit, "ans2Input")

        self.controller = SignupController()

        if self.signupBtn:
            self.signupBtn.clicked.connect(self.create_account)
        if self.backToLoginBtn:
            self.backToLoginBtn.clicked.connect(self.go_back)

        # Connect question filtering
        if self.q1Input:
            self.q1Input.currentIndexChanged.connect(self.sync_questions)

        # Initialize q2 properly
        self.sync_questions()


    # ------------ RESIZE EVENT FOR PROPER SCALING ------------
    def resizeEvent(self, event):
        super().resizeEvent(event)

        cw = self.findChild(QtWidgets.QWidget, "centralwidget")
        if cw and not self._bg_pix.isNull():
            scaled_bg = self._bg_pix.scaled(
                cw.size(),
                Qt.AspectRatioMode.KeepAspectRatioByExpanding,
                Qt.TransformationMode.SmoothTransformation
            )
            self._bg_label.setPixmap(scaled_bg)
            self._bg_label.resize(cw.size())
            self._bg_label.move(0, 0)

        if not self._orig_logo_pix.isNull() and self.logo_label:
            target_w = int(self.width() * self.MAX_PROP)
            target_w = max(self.ABS_MIN_W, min(target_w, self.ABS_MAX_W))

            scaled_logo = self._orig_logo_pix.scaled(
                target_w, target_w,
                Qt.AspectRatioMode.KeepAspectRatio,
                Qt.TransformationMode.SmoothTransformation
            )
            self.logo_label.setPixmap(scaled_logo)


    
    
    def validate_step1(self):
        username = self.userInput.text().strip() if self.userInput else ""
        password = self.passInput.text().strip() if self.passInput else ""
        homepass = self.homepassInput.text().strip() if self.homepassInput else ""

        # 1. Required fields
        if not username or not password or not homepass:
            QtWidgets.QMessageBox.warning(
                self,
                "Missing Data",
                "Please fill in username, password, and home password."
            )
            return

        # 2. Password validation (same logic style as change_password)
        if len(password) < 8 or \
           not re.search(r"[A-Z]", password) or \
           not re.search(r"[a-z]", password) or \
           not re.search(r"\d", password):
            QtWidgets.QMessageBox.warning(
                self,
                "Invalid Password",
                "Password must be at least 8 characters long and include:\n"
                "- One uppercase letter\n"
                "- One lowercase letter\n"
                "- One number"
            )
            return

        # 3. Homepass validation (exactly 5 digits, numbers only)
        if not homepass.isdigit() or len(homepass) != 5:
            QtWidgets.QMessageBox.warning(
                self,
                "Invalid Home Password",
                "Home password must be exactly 5 digits (numbers only)."
            )
            return

        # 4. Check if username already exists
        try:
            if self.controller.username_exists(username):
                QtWidgets.QMessageBox.warning(
                    self,
                    "Username Taken",
                    "This username is already in use. Please choose another one."
                )
                return
        except Exception as e:
            QtWidgets.QMessageBox.critical(
                self,
                "Error",
                f"Failed to check username: {str(e).splitlines()[0]}"
            )
            return

        # âœ… All good â†’ go to security questions page
        if self.stacked and self.securityPage:
            self.stacked.setCurrentWidget(self.securityPage)

    # ------------ FIXED QUESTION FILTERING (NO DUPLICATES EVER) ------------
    def sync_questions(self):
        if not self.q1Input or not self.q2Input:
            return

        chosen = self.q1Input.currentText().strip().lower()

        all_questions = [
            "What is your childhood nickname?",
            "What is the name of your first pet?",
            "What is the name of your first best friend?",
            "What city were you born in?",
            "What was the name of your first school?",
            "What was the name of your favorite teacher?",
            "What is your favorite food?",
            "What is your favorite movie?"
        ]

        self.q2Input.clear()

        for q in all_questions:
            if q.strip().lower() != chosen:
                self.q2Input.addItem(q)

        if self.q2Input.count() > 0:
            self.q2Input.setCurrentIndex(0)


    # ------------ CREATE ACCOUNT (BACKEND) ------------
    def create_account(self):
        username = self.userInput.text().strip() if self.userInput else ""
        password = self.passInput.text().strip() if self.passInput else ""
        homepass = self.homepassInput.text().strip() if self.homepassInput else ""

        q1 = self.q1Input.currentText() if self.q1Input else ""
        a1 = self.ans1Input.text().strip() if self.ans1Input else ""
        q2 = self.q2Input.currentText() if self.q2Input else ""
        a2 = self.ans2Input.text().strip() if self.ans2Input else ""

        if not username or not password or not a1 or not a2:
            QtWidgets.QMessageBox.warning(self, "Missing Data", "Please fill in all required fields.")
            return

        ok, msg = validate_password(password)
        if not ok:
            QtWidgets.QMessageBox.warning(self, "Invalid Password", msg)
            return

        success, message = self.controller.signup(
            username, password, homepass, q1, a1, q2, a2
        )

        if not success:
            QtWidgets.QMessageBox.warning(self, "Signup Failed", message)
            return

        QtWidgets.QMessageBox.information(self, "Success", message)
        self.go_back()


    # ------------ GO BACK TO LOGIN (AVOID CIRCULAR IMPORT) ------------
    def go_back(self):
        from views.login import LoginWindow
        self.close()
        self.login = LoginWindow()
        self.login.show()






student.py:
    
    
    
    
    # import sys
# from os import path
# from PyQt6 import QtWidgets, uic
# from PyQt6.QtGui import QPixmap
# from PyQt6.QtCore import Qt
# from PyQt6.QtWidgets import QWidget, QHBoxLayout, QPushButton, QTableWidgetItem

# BASE_DIR = path.dirname(path.abspath(__file__))
# PROJECT_ROOT = path.abspath(path.join(BASE_DIR, ".."))

# UI_FILE = path.join(PROJECT_ROOT, "ui", "student.ui")
# BG_FILE = path.join(PROJECT_ROOT, "assets", "images", "bg1.png")


# class StudentWindow(QtWidgets.QMainWindow):
#     def __init__(self):
#         super().__init__()

#         # Load UI into QMainWindow
#         uic.loadUi(UI_FILE, self)

#         # ----------------------------
#         # Stacked widget navigation
#         # ----------------------------
#         try:
#             self.stacked = self.findChild(QtWidgets.QStackedWidget, "stackedWidget")
#             self.mainStudentPage = self.findChild(QtWidgets.QWidget, "mainStudentPage")
#             self.enrollStudentPage = self.findChild(QtWidgets.QWidget, "enrollStudentPage")
#             self.verificationPage = self.findChild(QtWidgets.QWidget, "verificationPage")
#             self.confirmationPage = self.findChild(QtWidgets.QWidget, "confirmationPage")
#             self.editStudentPage = self.findChild(QtWidgets.QWidget, "editStudentPage")
#             self.viewGuardianPage = self.findChild(QtWidgets.QWidget, "viewGuardianPage")
#             self.addGuardianPage = self.findChild(QtWidgets.QWidget, "addGuardianPage")
#             self.editGuardianPage = self.findChild(QtWidgets.QWidget, "editGuardianPage")

#             # set initial page to mainStudentPage
#             if self.stacked and self.mainStudentPage:
#                 self.stacked.setCurrentWidget(self.mainStudentPage)

#             # navigation buttons
#             self.enrolStudBtn = self.findChild(QtWidgets.QPushButton, "enrollStudBtn")
#             self.backToMainBtn = self.findChild(QtWidgets.QPushButton, "backToMainBtn")
#             self.enrollBtn = self.findChild(QtWidgets.QPushButton, "enrollBtn")
#             self.backToInputBtn = self.findChild(QtWidgets.QPushButton, "backToInputBtn")
#             self.confirmBtn = self.findChild(QtWidgets.QPushButton, "confirmBtn")
#             self.saveEditBtn = self.findChild(QtWidgets.QPushButton, "saveEditmBtn")
#             self.backToMainBtn_3 = self.findChild(QtWidgets.QPushButton, "backToMainBtn_3")
#             self.backToMainBtn_2 = self.findChild(QtWidgets.QPushButton, "backToMainBtn_2")
#             self.backToViewGuardianBtn = self.findChild(QtWidgets.QPushButton, "backToViewGuardianBtn")
#             self.backToViewGuardianBtn_2 = self.findChild(QtWidgets.QPushButton, "backToViewGuardianBtn_2")
#             self.addBtn = self.findChild(QtWidgets.QPushButton, "addBtn")
#             self.saveEditBtn_2 = self.findChild(QtWidgets.QPushButton, "saveEditmBtn_2")
#             self.addGuardianBtn = self.findChild(QtWidgets.QPushButton, "addGuardianBtn")

#             # connect buttons (only if both button and target page exist)
#             if self.enrolStudBtn and self.enrollStudentPage:
#                 self.enrolStudBtn.clicked.connect(
#                     lambda: self.stacked.setCurrentWidget(self.enrollStudentPage)
#                 )

#             if self.backToMainBtn and self.mainStudentPage:
#                 self.backToMainBtn.clicked.connect(
#                     lambda: self.stacked.setCurrentWidget(self.mainStudentPage)
#                 )
#             if self.backToMainBtn_2 and self.mainStudentPage:
#                 self.backToMainBtn_2.clicked.connect(
#                     lambda: self.stacked.setCurrentWidget(self.mainStudentPage)
#                 )
#             if self.backToMainBtn_3 and self.mainStudentPage:
#                 self.backToMainBtn_3.clicked.connect(
#                     lambda: self.stacked.setCurrentWidget(self.mainStudentPage)
#                 )

#             if self.enrollBtn and self.verificationPage:
#                 self.enrollBtn.clicked.connect(
#                     lambda: self.stacked.setCurrentWidget(self.verificationPage)
#                 )

#             if self.backToInputBtn and self.enrollStudentPage:
#                 self.backToInputBtn.clicked.connect(
#                     lambda: self.stacked.setCurrentWidget(self.enrollStudentPage)
#                 )

#             if self.confirmBtn and self.confirmationPage:
#                 self.confirmBtn.clicked.connect(
#                     lambda: self.stacked.setCurrentWidget(self.confirmationPage)
#                 )

#             if self.saveEditBtn and self.mainStudentPage:
#                 self.saveEditBtn.clicked.connect(
#                     lambda: self.stacked.setCurrentWidget(self.mainStudentPage)
#                 )

#             # Guardian page navigation (best guess from names)
#             if self.addBtn and self.addGuardianPage:
#                 self.addBtn.clicked.connect(
#                     lambda: self.stacked.setCurrentWidget(self.addGuardianPage)
#                 )

#             if self.backToViewGuardianBtn and self.viewGuardianPage:
#                 self.backToViewGuardianBtn.clicked.connect(
#                     lambda: self.stacked.setCurrentWidget(self.viewGuardianPage)
#                 )

#             if self.backToViewGuardianBtn_2 and self.viewGuardianPage:
#                 self.backToViewGuardianBtn_2.clicked.connect(
#                     lambda: self.stacked.setCurrentWidget(self.viewGuardianPage)
#                 )

#             if self.saveEditBtn_2 and self.viewGuardianPage:
#                 self.saveEditBtn_2.clicked.connect(
#                     lambda: self.stacked.setCurrentWidget(self.viewGuardianPage)
#                 )

#             if self.addGuardianBtn and self.addGuardianPage:
#                 self.addGuardianBtn.clicked.connect(
#                     lambda: self.stacked.setCurrentWidget(self.addGuardianPage)
#                 )

#         except Exception:
#             # ignore if stacked-widget/pages/buttons are not present
#             pass

#         # --- Background image using QLabel (behind everything) ---
#         cw = self.findChild(QtWidgets.QWidget, "centralwidget")
#         self._bg_label = QtWidgets.QLabel(cw)
#         self._bg_pix = QPixmap(BG_FILE)
#         self._bg_label.setPixmap(self._bg_pix)
#         self._bg_label.setScaledContents(False)
#         self._bg_label.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
#         self._bg_label.lower()
#         self._bg_label.resize(cw.size())

#         # STUDENT TABLE
#         self.studentTable = self.findChild(QtWidgets.QTableWidget, "studentTable")

#         if self.studentTable is None:
#             print("Warning: studentTable not found")
#         else:
#             if self.studentTable.columnCount() < 3:
#                 self.studentTable.setColumnCount(3)
#                 self.studentTable.setHorizontalHeaderLabels(["ID", "Name", "Actions"])

#             self.setup_table(self.studentTable)

#             sample_students = [
#                 {"id": "S001", "name": "Name of student 1"},
#                 {"id": "S002", "name": "Name of student 2"},
#                 {"id": "S003", "name": "Name of student 3"},
#                 {"id": "S004", "name": "Name of student 4"},
#                 {"id": "S005", "name": "Name of student 5"},
#             ]

#             for s in sample_students:
#                 self.add_student_row(s["id"], s["name"])

#         # GUARDIAN TABLE
#         self.guardianTable = self.findChild(QtWidgets.QTableWidget, "guardianTable")

#         if self.guardianTable is None:
#             print("Warning: guardianTable not found")
#         else:
#             if self.guardianTable.columnCount() < 3:
#                 self.guardianTable.setColumnCount(3)
#                 self.guardianTable.setHorizontalHeaderLabels(["ID", "Name", "Actions"])

#             self.setup_table(self.guardianTable)

#             sample_guardians = [
#                 {"id": "G001", "name": "Guardian 1"},
#                 {"id": "G002", "name": "Guardian 2"},
#                 {"id": "G003", "name": "Guardian 3"},
#                 {"id": "G004", "name": "Guardian 4"},
#                 {"id": "G005", "name": "Guardian 5"},
#             ]

#             for g in sample_guardians:
#                 self.add_guardian_row(g["id"], g["name"])

#     # ----------------------------------------------------------------------------
#     # Row creators
#     # ----------------------------------------------------------------------------
#     def add_student_row(self, student_id, name):
#         """
#         Student table: Edit, Delete, View Guardian
#         """
#         self._add_row_common(
#             table=self.studentTable,
#             record_id=student_id,
#             name=name,
#             include_view_btn=True,
#             is_guardian=False,
#         )

#     def add_guardian_row(self, guardian_id, name):
#         """
#         Guardian table: Edit, Delete
#         """
#         self._add_row_common(
#             table=self.guardianTable,
#             record_id=guardian_id,
#             name=name,
#             include_view_btn=False,
#             is_guardian=True,
#         )

#     def _add_row_common(self, table, record_id, name, include_view_btn: bool, is_guardian: bool):
#         """
#         Internal helper to create a row with:
#           column 0: ID
#           column 1: Name
#           column 2: Actions (buttons)
#         """
#         if table is None:
#             return

#         row = table.rowCount()
#         table.insertRow(row)

#         # ID cell
#         item_id = QTableWidgetItem(f"{record_id}")
#         item_id.setFlags(item_id.flags() ^ Qt.ItemFlag.ItemIsEditable)
#         item_id.setTextAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
#         table.setItem(row, 0, item_id)

#         # Name cell
#         item_name = QTableWidgetItem(f"{name}")
#         item_name.setFlags(item_name.flags() ^ Qt.ItemFlag.ItemIsEditable)
#         item_name.setTextAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
#         table.setItem(row, 1, item_name)

#         # Actions cell widget
#         action_cell = QWidget()
#         h = QHBoxLayout(action_cell)
#         h.setContentsMargins(0, 0, 0, 0)
#         h.setSpacing(8)
#         h.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)

#         # Always Edit + Delete
#         edit_btn = QPushButton("Edit")
#         edit_btn.setCursor(Qt.CursorShape.PointingHandCursor)
#         edit_btn.setFixedHeight(30)

#         delete_btn = QPushButton("Delete")
#         delete_btn.setCursor(Qt.CursorShape.PointingHandCursor)
#         delete_btn.setFixedHeight(30)

#         buttons = [edit_btn, delete_btn]

#         # Only for student table: View Guardian
#         view_btn = None
#         if include_view_btn:
#             view_btn = QPushButton("View Guardian")
#             view_btn.setCursor(Qt.CursorShape.PointingHandCursor)
#             view_btn.setFixedHeight(30)
#             buttons.append(view_btn)

#         # Font + style
#         btn_font = edit_btn.font()
#         btn_font.setPointSize(13)
#         btn_font.setUnderline(True)

#         for btn in buttons:
#             btn.setFont(btn_font)
#             btn.setStyleSheet("""
#                 QPushButton {
#                     border: none;
#                     background: transparent;
#                     color: #333333;
#                 }
#                 QPushButton:hover {
#                     color: #8b2fdb;
#                 }
#             """)
#             h.addWidget(btn)

#         # Connect signals
#         if is_guardian:
#             edit_btn.clicked.connect(lambda checked=False, gid=record_id: self.edit_guardian(gid))
#             delete_btn.clicked.connect(lambda checked=False, gid=record_id: self.delete_guardian(gid))
#         else:
#             edit_btn.clicked.connect(lambda checked=False, sid=record_id: self.edit_student(sid))
#             delete_btn.clicked.connect(lambda checked=False, sid=record_id: self.delete_student(sid))

#         if view_btn is not None:
#             view_btn.clicked.connect(lambda checked=False, sid=record_id: self.view_guardian(sid))

#         table.setCellWidget(row, 2, action_cell)

#     # ----------------------------------------------------------------------------
#     # function to make the table responsive / stretch columns evenly
#     def setup_table(self, table):
#         if table is None:
#             return

#         # Make table adjust to contents policy (optional)
#         try:
#             table.setSizeAdjustPolicy(
#                 QtWidgets.QAbstractScrollArea.SizeAdjustPolicy.AdjustToContents
#             )
#         except Exception:
#             pass

#         # Increase font size for better readability
#         try:
#             font = table.font()
#             font.setPointSize(13)
#             table.setFont(font)
#         except Exception:
#             pass

#         header = table.horizontalHeader()
#         # default: ID interactive so we can set a width, Name stretch, Actions Interactive
#         try:
#             header.setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeMode.Interactive)
#             header.setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeMode.Stretch)
#             header.setSectionResizeMode(2, QtWidgets.QHeaderView.ResizeMode.Interactive)
#         except Exception:
#             # fallback: stretch all
#             try:
#                 header.setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Stretch)
#             except Exception:
#                 pass

#         # Widen ID column
#         try:
#             table.setColumnWidth(0, 150)
#         except Exception:
#             pass

#         # Widen Actions column
#         try:
#             table.setColumnWidth(2, 300)
#         except Exception:
#             pass

#         # Set row and header heights
#         try:
#             table.verticalHeader().setDefaultSectionSize(54)
#         except Exception:
#             pass
#         try:
#             table.horizontalHeader().setFixedHeight(48)
#         except Exception:
#             pass

#         # Hide vertical row numbers
#         try:
#             table.verticalHeader().setVisible(False)
#         except Exception:
#             pass

#         # Remove all borders/lines in table
#         table.setStyleSheet("""
#         QTableWidget {
#             gridline-color: transparent;
#             border: none;
#         }
#         QTableWidget::item {
#             border: none;
#             padding: 8px;
#         }
#         QHeaderView::section {
#             border: none;
#             background: transparent;
#             padding-left: 12px;
#         }
#         """)

#     # ----------------------------------------------------------------------------
#     # Action handlers
#     # ----------------------------------------------------------------------------
#     def edit_student(self, student_id):
#         print("Edit student:", student_id)
#         try:
#             if self.stacked and self.editStudentPage:
#                 self.stacked.setCurrentWidget(self.editStudentPage)
#         except Exception:
#             pass

#     def delete_student(self, student_id):
#         print("Delete student:", student_id)
#         # TODO: confirm then remove from DB and refresh table

#     def view_guardian(self, student_id):
#         print("View guardian for student:", student_id)
#         try:
#             if self.stacked and self.viewGuardianPage:
#                 self.stacked.setCurrentWidget(self.viewGuardianPage)
#         except Exception:
#             pass

#     def edit_guardian(self, guardian_id):
#         print("Edit guardian:", guardian_id)
#         try:
#             if self.stacked and self.editGuardianPage:
#                 self.stacked.setCurrentWidget(self.editGuardianPage)
#         except Exception:
#             pass

#     def delete_guardian(self, guardian_id):
#         print("Delete guardian:", guardian_id)
#         # TODO: confirm then remove from DB and refresh table

#     # ----------------------------------------------------------------------------
#     def resizeEvent(self, event):
#         super().resizeEvent(event)
#         # Resize background to fill area
#         try:
#             cw = self.findChild(QtWidgets.QWidget, "centralwidget")
#             scaled_bg = self._bg_pix.scaled(
#                 cw.size(),
#                 Qt.AspectRatioMode.KeepAspectRatioByExpanding,
#                 Qt.TransformationMode.SmoothTransformation,
#             )
#             self._bg_label.setPixmap(scaled_bg)
#             self._bg_label.resize(cw.size())
#             self._bg_label.move(0, 0)
#         except Exception:
#             pass


# def main():
#     app = QtWidgets.QApplication(sys.argv)
#     win = StudentWindow()
#     win.show()
#     sys.exit(app.exec())


# if __name__ == "__main__":
#     main()


# import cv2
# import face_recognition
# from PyQt6.QtWidgets import QDialog, QLabel, QVBoxLayout
# from PyQt6.QtGui import QImage
# from PyQt6.QtCore import QTimer
# import sys, os
# from os import path
# from PyQt6 import QtWidgets, uic
# from PyQt6.QtGui import QPixmap
# from PyQt6.QtCore import Qt, QDate
# from PyQt6.QtWidgets import QWidget, QHBoxLayout, QPushButton, QTableWidgetItem

# from controller.StudentController import StudentController

# BASE_DIR = path.dirname(path.abspath(__file__))
# PROJECT_ROOT = path.abspath(path.join(BASE_DIR, ".."))

# UI_FILE = path.join(PROJECT_ROOT, "ui", "student.ui")
# BG_FILE = path.join(PROJECT_ROOT, "assets", "images", "bg1.png")


# class StudentWindow(QtWidgets.QMainWindow):
#     def __init__(self, username):
#         super().__init__()
#         self.username = username
#         self.controller = StudentController()

#         # Load UI
#         uic.loadUi(UI_FILE, self)

        
#         self.resize(1250, 800)

#         # --- center window ---
#         screen = QtWidgets.QApplication.primaryScreen().availableGeometry()
#         win = self.frameGeometry()
#         win.moveCenter(screen.center())
#         self.move(win.topLeft())
        
        
#         # Background setup
#         cw = self.findChild(QtWidgets.QWidget, "centralwidget")

#         self._bg_label = QtWidgets.QLabel(cw)
#         self._bg_pix = QPixmap(BG_FILE)

#         if self._bg_pix.isNull():
#             print("âŒ BG not found:", BG_FILE)
#         else:
#             print("âœ… BG loaded:", BG_FILE)

#         self._bg_label.setPixmap(self._bg_pix)
#         self._bg_label.setScaledContents(True)
#         self._bg_label.lower()           # push behind all widgets
#         self._bg_label.resize(cw.size()) # temp resize
        
#         # SEARCH BAR
#         self.searchStudent = self.findChild(QtWidgets.QLineEdit, "searchStudent")
#         if self.searchStudent:
#             self.searchStudent.textChanged.connect(self.apply_search)


#         # STACKED PAGES
#         self.stacked = self.findChild(QtWidgets.QStackedWidget, "stackedWidget")
#         self.mainStudentPage = self.findChild(QtWidgets.QWidget, "mainStudentPage")
#         self.enrollStudentPage = self.findChild(QtWidgets.QWidget, "enrollStudentPage")
#         self.verificationPage = self.findChild(QtWidgets.QWidget, "verificationPage")
#         self.confirmationPage = self.findChild(QtWidgets.QWidget, "confirmationPage")
#         self.editStudentPage = self.findChild(QtWidgets.QWidget, "editStudentPage")
#         self.viewGuardianPage = self.findChild(QtWidgets.QWidget, "viewGuardianPage")
#         self.addGuardianPage = self.findChild(QtWidgets.QWidget, "addGuardianPage")
#         self.editGuardianPage = self.findChild(QtWidgets.QWidget, "editGuardianPage")

#         # DEFAULT PAGE
#         self.stacked.setCurrentWidget(self.mainStudentPage)

#         # ============= BUTTONS (old UI behavior) =============

#         btn = self.findChild(QtWidgets.QPushButton, "enrollStudBtn")
#         if btn:
#             btn.clicked.connect(self.open_enroll_page)
            
        
#         save_btn = self.findChild(QtWidgets.QPushButton, "saveEditBtn")
#         if save_btn:
#             save_btn.clicked.connect(self.save_student_changes)


#         # All back buttons â†’ mainStudentPage
#         # True back to Dashboard
#         btn = self.findChild(QtWidgets.QPushButton, "backToDashboardBtn")
#         if btn:
#             btn.clicked.connect(self.go_to_dashboard)

#         # The rest go back to student main page
#         for name in ["backToMainBtn", "backToMainBtn_2", "backToMainBtn_3", "goBacktoDasboardBtn"]:
#             btn = self.findChild(QtWidgets.QPushButton, name)
#             if btn:
#                 btn.clicked.connect(lambda _, p=self.mainStudentPage: self.stacked.setCurrentWidget(p))

#         # Enrollment flow
#         # btn = self.findChild(QtWidgets.QPushButton, "enrollBtn")
#         # if btn:
#         #     btn.clicked.connect(lambda: self.stacked.setCurrentWidget(self.verificationPage))

#         btn = self.findChild(QtWidgets.QPushButton, "enrollBtn")
#         if btn:
#             btn.clicked.connect(self.validate_enroll_inputs)

        
#         btn = self.findChild(QtWidgets.QPushButton, "backToInputBtn")
#         if btn:
#             btn.clicked.connect(lambda: self.stacked.setCurrentWidget(self.enrollStudentPage))

#         btn = self.findChild(QtWidgets.QPushButton, "confirmBtn")
#         if btn:
#             btn.clicked.connect(self.finish_enrollment)


#         delete_view_btn = self.findChild(QtWidgets.QPushButton, "deleteBtn_2")
#         if delete_view_btn:
#             delete_view_btn.clicked.connect(self.delete_guardian_view)

#         back_view_btn = self.findChild(QtWidgets.QPushButton, "backToViewGuardianBtn")
#         if back_view_btn:
#             back_view_btn.clicked.connect(lambda: self.stacked.setCurrentWidget(self.viewGuardianPage))


#         self.addGuardianBtn.clicked.connect(self.open_add_guardian_page)
#         self.addSaveBtn.clicked.connect(self.save_guardian)

#         self.scanFaceBtn.clicked.connect(self.scan_guardian_face)
#         self.retakeBtn.clicked.connect(self.retake_guardian_face)
#         self.deleteBtn.clicked.connect(self.delete_scanned_face)

        
#         # VIEW GUARDIAN PAGE
#         self.guardianTable = self.findChild(QtWidgets.QTableWidget, "guardianTable")
#         self.studentNameDisplay = self.findChild(QtWidgets.QLabel, "studentNameDisplay")

#         # Apply same table formatting as studentTable
#         if self.guardianTable:
#             self.setup_table(self.guardianTable)

#         self.newGuardianName = self.findChild(QtWidgets.QLineEdit, "newGuardianNameInput")
#         self.newGuardianDOB = self.findChild(QtWidgets.QDateEdit, "newGuardianDOBInput")

#         self.scanFaceBtn = self.findChild(QtWidgets.QPushButton, "scanFaceBtn")
#         self.retakeBtn = self.findChild(QtWidgets.QPushButton, "retakeBtn")
#         self.deleteBtn = self.findChild(QtWidgets.QPushButton, "deleteBtn")
#         self.imgPlaceholder = self.findChild(QtWidgets.QLabel, "imgPlaceholder")

#         self.addSaveBtn = self.findChild(QtWidgets.QPushButton, "addSaveBtn")
#         self.addGuardianBtn = self.findChild(QtWidgets.QPushButton, "addGuardianBtn")


#         # Tracks guardian data
#         self.current_student_for_guardian = None
#         self.current_guardian_image_path = None
#         self.current_guardian_encoding = None

#         save_edit_btn = self.findChild(QtWidgets.QPushButton, "saveEditBtn_2")
#         if save_edit_btn:
#             save_edit_btn.clicked.connect(self.save_edit_guardian)

        
#         # Guardian buttons
#         guardian_routes = [
#             ("addBtn", self.addGuardianPage),
#             ("addGuardianBtn", self.addGuardianPage),
#             ("backToViewGuardianBtn_2", self.viewGuardianPage),
#         ]
#         for name, page in guardian_routes:
#             btn = self.findChild(QtWidgets.QPushButton, name)
#             if btn:
#                 btn.clicked.connect(lambda _, p=page: self.stacked.setCurrentWidget(p))

#         # ============= TABLE =============

#         self.studentTable = self.findChild(QtWidgets.QTableWidget, "studentTable")
#         self.setup_table(self.studentTable)
#         self.load_students()

#         # # Background
#         # cw = self.findChild(QtWidgets.QWidget, "centralwidget")
#         # self._bg_label = QtWidgets.QLabel(cw)
#         # self._bg_pix = QPixmap(BG_FILE)
#         # self._bg_label.setPixmap(self._bg_pix)
#         # self._bg_label.lower()
#         # self._bg_label.resize(cw.size())

#         # ENROLL INPUTS
#         self.studIDLabel = self.findChild(QtWidgets.QLabel, "studIDLabel")
#         self.studFname = self.findChild(QtWidgets.QLineEdit, "studFnameInput")
#         self.studMname = self.findChild(QtWidgets.QLineEdit, "studMnameInput")
#         self.studLname = self.findChild(QtWidgets.QLineEdit, "studLnameInput")
#         self.studDOB = self.findChild(QtWidgets.QDateEdit, "studDOBInput")
#         self.studSex = self.findChild(QtWidgets.QComboBox, "studSexInput")
#         self.contact = self.findChild(QtWidgets.QLineEdit, "contactInput")

#         self.motherName = self.findChild(QtWidgets.QLineEdit, "motherNameInput")
#         self.motherDOB = self.findChild(QtWidgets.QDateEdit, "motherDOBInput")
#         self.fatherName = self.findChild(QtWidgets.QLineEdit, "fatherNameInput")
#         self.fatherDOB = self.findChild(QtWidgets.QDateEdit, "fatherDOBInput")
#         self.guardianName = self.findChild(QtWidgets.QLineEdit, "guardianNameInput")
#         self.guardianDOB = self.findChild(QtWidgets.QDateEdit, "guardianDOBInput")

#         self.guardianDOBEdit = self.findChild(QtWidgets.QDateEdit, "guardianDOBEdit")
#         self.guardianDOBEdit.setSpecialValueText("")  # show blank if at minimum
#         self.guardianDOBEdit.setDate(self.guardianDOBEdit.minimumDate())

        
#         self.verifyCheck = self.findChild(QtWidgets.QCheckBox, "verifyCheck")
#         self.confirmLabel = self.findChild(QtWidgets.QLabel, "confirmLabel")

    
    
#     def resizeEvent(self, event):
#         super().resizeEvent(event)

#         if hasattr(self, "_bg_label") and hasattr(self, "_bg_pix"):
#             cw = self.findChild(QtWidgets.QWidget, "centralwidget")

#             scaled = self._bg_pix.scaled(
#                 cw.size(),
#                 Qt.AspectRatioMode.KeepAspectRatioByExpanding,
#                 Qt.TransformationMode.SmoothTransformation
#             )

#             self._bg_label.setPixmap(scaled)
#             self._bg_label.resize(cw.size())

#     # =====================
#     # TABLE SETTINGS
#     # =====================
#     # def setup_table(self, table):
#     #     header = table.horizontalHeader()
#     #     header.setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeMode.Interactive)
#     #     header.setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeMode.Stretch)
#     #     header.setSectionResizeMode(2, QtWidgets.QHeaderView.ResizeMode.Interactive)

#     #     table.setColumnWidth(0, 150)
#     #     table.setColumnWidth(2, 350)


#     #     table.verticalHeader().setDefaultSectionSize(54)
#     #     table.horizontalHeader().setFixedHeight(48)
#     #     table.verticalHeader().setVisible(False)

#     #     font = table.font()
#     #     font.setPointSize(13)
#     #     table.setFont(font)

#     #     table.setStyleSheet("""
#     #     QTableWidget {
#     #         gridline-color: transparent;
#     #         border: none;
#     #     }
#     #     QTableWidget::item {
#     #         border: none;
#     #         padding: 8px;
#     #     }
#     #     QHeaderView::section {
#     #         border: none;
#     #         background: transparent;
#     #         padding-left: 12px;
#     #     }
#     #     """)
    
#     def setup_table(self, table):
#         header = table.horizontalHeader()
#         header.setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeMode.Interactive)
#         header.setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeMode.Stretch)
#         header.setSectionResizeMode(2, QtWidgets.QHeaderView.ResizeMode.Interactive)

#         table.setColumnWidth(0, 150)
#         table.setColumnWidth(2, 350)

#         table.verticalHeader().setDefaultSectionSize(54)
#         table.horizontalHeader().setFixedHeight(48)
#         table.verticalHeader().setVisible(False)

#         font = table.font()
#         font.setPointSize(13)
#         table.setFont(font)

#         # ðŸ‘‰ Center ONLY the last column header ("Action" / "Actions")
#         last_col = table.columnCount() - 1
#         if last_col >= 0:
#             item = table.horizontalHeaderItem(last_col)
#             if item:
#                 item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)

#         table.setStyleSheet("""
#         QTableWidget {
#             gridline-color: transparent;
#             border: none;
#         }
#         QTableWidget::item {
#             border: none;
#             padding: 8px;
#         }
#         QHeaderView::section {
#             border: none;
#             background: transparent;
#             padding-left: 12px;      /* ðŸ”¹ keep old padding for ID & Name */
#         }
#         QHeaderView::section:last {
#             padding-left: 0px;       /* ðŸ”¹ remove padding ONLY for Actions column */
#         }
#         """)

#     # =====================
#     # LOAD STUDENTS
#     # =====================
#     def load_students(self):
#         self.studentTable.setRowCount(0)
#         students = self.controller.get_students(self.username)

#         for s in students:
#             fullname = f"{s['studlname']}, {s['studfname']} {s.get('studmname','')}"
#             self.add_student_row(s["studid"], fullname)

#     # =====================
#     # ADD ROW + BUTTONS
#     # =====================
#     def add_student_row(self, student_id, name):
#         row = self.studentTable.rowCount()
#         self.studentTable.insertRow(row)

#         id_item = QTableWidgetItem(student_id)
#         id_item.setFlags(id_item.flags() ^ Qt.ItemFlag.ItemIsEditable)
#         self.studentTable.setItem(row, 0, id_item)

#         name_item = QTableWidgetItem(name)
#         name_item.setFlags(name_item.flags() ^ Qt.ItemFlag.ItemIsEditable)
#         self.studentTable.setItem(row, 1, name_item)

#         # action_cell = QWidget()
#         # layout = QHBoxLayout(action_cell)
#         # layout.setContentsMargins(0, 0, 0, 0)

#         # # Buttons
#         # edit_btn = QPushButton("Edit")
#         # delete_btn = QPushButton("Delete")
#         # view_btn = QPushButton("View Guardian")

#         # for btn in (edit_btn, delete_btn, view_btn):
#         #     btn.setCursor(Qt.CursorShape.PointingHandCursor)
#         #     btn.setStyleSheet("""
#         #         QPushButton {
#         #             border: none;
#         #             background: transparent;
#         #             color: #333;
#         #         }
#         #         QPushButton:hover {
#         #             color: #8b2fdb;
#         #         }
#         #     """)
#         #     layout.addWidget(btn)

        
        
#         action_cell = QWidget()
#         layout = QHBoxLayout(action_cell)
#         layout.setContentsMargins(0, 0, 0, 0)
#         layout.setAlignment(Qt.AlignmentFlag.AlignCenter)   # ðŸ”¥ CENTER ALL 3 BUTTONS

#         # Buttons
#         edit_btn = QPushButton("Edit")
#         delete_btn = QPushButton("Delete")
#         view_btn = QPushButton("View Guardian")

#         for btn in (edit_btn, delete_btn, view_btn):
#             btn.setCursor(Qt.CursorShape.PointingHandCursor)
#             btn.setStyleSheet("""
#                 QPushButton {
#                     border: none;
#                     background: transparent;
#                     color: #333;
#                 }
#                 QPushButton:hover {
#                     color: #8b2fdb;
#                 }
#             """)
#             layout.addWidget(btn)

        
#         # CONNECTIONS (WORKING NOW)
#         edit_btn.clicked.connect(lambda _, sid=student_id: self.edit_student(sid))
#         delete_btn.clicked.connect(lambda _, sid=student_id: self.delete_student(sid))
#         view_btn.clicked.connect(lambda _, sid=student_id: self.view_guardian(sid))

#         self.studentTable.setCellWidget(row, 2, action_cell)

#     # =====================
#     # BUTTON HANDLERS
#     # =====================
#     def edit_student(self, studID):
#         print("Editing student:", studID)

#         # Fetch from DB
#         student = self.controller.get_student(studID)
#         if not student:
#             QtWidgets.QMessageBox.warning(self, "Error", "Student not found.")
#             return

#         # Store current editing ID
#         self.current_edit_id = studID

#         # ========== BASIC INFO ==========
#         self.findChild(QtWidgets.QLineEdit, "studFnameEdit").setText(student["studfname"])
#         self.findChild(QtWidgets.QLineEdit, "studMnameEdit").setText(student["studmname"] or "")
#         self.findChild(QtWidgets.QLineEdit, "studLnameEdit").setText(student["studlname"])
#         self.findChild(QtWidgets.QLineEdit, "contactInputEdit").setText(student["studcontact"])
#         self.findChild(QtWidgets.QComboBox, "studSexEdit").setCurrentText(student["studsex"])

#         # ========== SAFE DOB FIELDS ==========
#         self.set_safe_date("studDOBEdit", student["studdob"])
#         self.set_safe_date("motherDOBEdit", student["motherdob"])
#         self.set_safe_date("fatherDOBEdit", student["fatherdob"])
#         self.set_safe_date("guardianDOBEdit", student["guardiandob"])

#         # ========== NAMES ==========
#         self.findChild(QtWidgets.QLineEdit, "motherNameEdit").setText(student["mothername"] or "")
#         self.findChild(QtWidgets.QLineEdit, "fatherNameEdit").setText(student["fathername"] or "")
#         self.findChild(QtWidgets.QLineEdit, "guardianNameEdit").setText(student["guardianname"] or "")

#         # Switch page
#         self.stacked.setCurrentWidget(self.editStudentPage)

#     def set_safe_date(self, name, value):
#         widget = self.findChild(QtWidgets.QDateEdit, name)
#         if widget is None:
#             return
#         if value is None:
#             widget.setDate(widget.minimumDate())
#         else:
#             widget.setDate(value)

    
#     def save_student_changes(self):
#         # --- Required fields ---
#         fname = self.findChild(QtWidgets.QLineEdit, "studFnameEdit").text().strip()
#         lname = self.findChild(QtWidgets.QLineEdit, "studLnameEdit").text().strip()
#         contact = self.findChild(QtWidgets.QLineEdit, "contactInputEdit").text().strip()

#         errors = []
#         if fname == "":
#             errors.append("â€¢ First name is required.")
#         if lname == "":
#             errors.append("â€¢ Last name is required.")
#         if contact == "":
#             errors.append("â€¢ Emergency contact is required.")

#         # If required fields missing â†’ STOP & warn
#         if errors:
#             QtWidgets.QMessageBox.warning(
#                 self,
#                 "Missing Required Fields",
#                 "Please complete the following fields:\n\n" + "\n".join(errors)
#             )
#             return

#         # --- Confirm saving ---
#         confirm = QtWidgets.QMessageBox.question(
#             self,
#             "Confirm",
#             "Are you sure you want to save the changes?",
#             QtWidgets.QMessageBox.StandardButton.Yes | QtWidgets.QMessageBox.StandardButton.No
#         )

#         if confirm != QtWidgets.QMessageBox.StandardButton.Yes:
#             return

#         # --- Prepare data ---
#         data = {
#             "studID": self.current_edit_id,
#             "studFname": fname,
#             "studMname": self.findChild(QtWidgets.QLineEdit, "studMnameEdit").text(),
#             "studLname": lname,
#             "studDOB": self.get_safe_date("studDOBEdit"),
#             "studSex": self.findChild(QtWidgets.QComboBox, "studSexEdit").currentText(),
#             "studContact": contact,

#             # Parents
#             "motherName": self.findChild(QtWidgets.QLineEdit, "motherNameEdit").text(),
#             "motherDOB": self.get_safe_date("motherDOBEdit"),

#             "fatherName": self.findChild(QtWidgets.QLineEdit, "fatherNameEdit").text(),
#             "fatherDOB": self.get_safe_date("fatherDOBEdit"),

#             # Guardian Info
#             "guardianName": self.findChild(QtWidgets.QLineEdit, "guardianNameEdit").text(),
#             "guardianDOB": self.get_safe_date("guardianDOBEdit"),
#         }


#         # --- Save to DB ---
#         self.controller.update_student(data)

#         QtWidgets.QMessageBox.information(
#             self,
#             "Success",
#             "Student information has been successfully updated!"
#         )

#         # Refresh table + go back
#         self.load_students()
#         self.stacked.setCurrentWidget(self.mainStudentPage)

    
#     # ---- SAFE DATE GETTER FOR ANY QDateEdit ----
#     def get_safe_date(self, name):
#         widget = self.findChild(QtWidgets.QDateEdit, name)
#         if widget is None:
#             return None  # field not found â†’ ignore instead of crash

#         date = widget.date()

#         # If user never touched it and it's still at minimum date â†’ treat as empty
#         if date == widget.minimumDate():
#             return None

#         return date.toString("yyyy-MM-dd")

    
    
#     def delete_student(self, student_id):
#         confirm = QtWidgets.QMessageBox.question(
#             self,
#             "Confirm Delete",
#             f"Are you sure you want to delete student {student_id}?\n\n"
#             "This will also delete all guardians for this student.",
#             QtWidgets.QMessageBox.StandardButton.Yes |
#             QtWidgets.QMessageBox.StandardButton.No
#         )

#         if confirm != QtWidgets.QMessageBox.StandardButton.Yes:
#             return

        
        
#         from controller.GuardianController import GuardianController
#         gc = GuardianController()

#         guardians = gc.get_guardians_for_student(student_id)
#         for g in guardians:
#             path = g["face_image_path"]
#             if path and os.path.exists(path):
#                 os.remove(path)
        
#         # Call controller to delete
#         self.controller.delete_student(student_id)

#         QtWidgets.QMessageBox.information(
#             self,
#             "Deleted",
#             "Student and all linked guardians have been deleted."
#         )

#         # Refresh table
#         self.load_students()


#     def view_guardian(self, studid):
#         from controller.GuardianController import GuardianController
#         self.current_student_for_guardian = studid

#         student = self.controller.get_student(studid)
#         full = f"{student['studlname']}, {student['studfname']} {student['studmname'] or ''}"
#         self.studentNameDisplay.setText(full)

#         self.load_guardians_table(studid)
#         self.stacked.setCurrentWidget(self.viewGuardianPage)



#     # =====================
#     # ENROLL
#     # =====================
#     def open_enroll_page(self):
#         self.clear_enroll_fields()  # ðŸ”¥ CLEAR FIELDS FIRST

#         new_id = self.controller.generate_student_id(self.username)
#         self.studIDLabel.setText(new_id)

#         self.stacked.setCurrentWidget(self.enrollStudentPage)

#     def finish_enrollment(self):
#         if not self.verifyCheck.isChecked():
#             QtWidgets.QMessageBox.warning(self, "Error", "Please confirm verification.")
#             return

#         data = {
#             "username": self.username,   # ðŸ”¥ REQUIRED FOR PROCEDURE
#             "studID": self.studIDLabel.text(),
#             "studLname": self.studLname.text(),
#             "studFname": self.studFname.text(),
#             "studMname": self.studMname.text(),
#             "studDOB": self.studDOB.text(),
#             "studSex": self.studSex.currentText(),
#             "studContact": self.contact.text(),
#             "motherName": self.motherName.text(),
#             "motherDOB": None if self.motherName.text().strip() == "" else self.motherDOB.date().toString("yyyy-MM-dd"),
#             "fatherName": self.fatherName.text(),
#             "fatherDOB": None if self.fatherName.text().strip() == "" else self.fatherDOB.date().toString("yyyy-MM-dd"),
#             "guardianName": self.guardianName.text(),
#             "guardianDOB": None if self.guardianName.text().strip() == "" else self.guardianDOB.text(),
#         }
#         self.controller.insert_student(self.username, data)

#         self.confirmLabel.setText(
#             f"Student {data['studLname']}, {data['studFname']} {data['studMname']} "
#             f"({data['studID']}) has been successfully enrolled."
#         )

#         self.stacked.setCurrentWidget(self.confirmationPage)
#         self.load_students()
        
    
#     def validate_enroll_inputs(self):
#         fname = self.studFname.text().strip()
#         lname = self.studLname.text().strip()
#         contact = self.contact.text().strip()

#         # Required field check
#         errors = []

#         if fname == "":
#             errors.append("â€¢ First name is required.")
#         if lname == "":
#             errors.append("â€¢ Last name is required.")
#         if contact == "":
#             errors.append("â€¢ Contact / emergency contact is required.")

#         # If ANY errors â†’ show warning and STOP
#         if errors:
#             QtWidgets.QMessageBox.warning(
#                 self,
#                 "Missing Required Fields",
#                 "Please fill in the following:\n\n" + "\n".join(errors)
#             )
#             return

#         # If all required fields are filled â†’ continue normally
#         self.stacked.setCurrentWidget(self.verificationPage)

        
    
#     def apply_search(self):
#         search = self.searchStudent.text().strip().lower()

#         # Clear table
#         self.studentTable.setRowCount(0)

#         # Query DB
#         students = self.controller.search_students(self.username, search)

#         # Display
#         for s in students:
#             fullname = f"{s['studlname']}, {s['studfname']} {s.get('studmname','')}"
#             self.add_student_row(s["studid"], fullname)

#     def go_to_dashboard(self):
#         from views.dashboard import AdminWindow  # safe import

#         self.dashboard = AdminWindow(self.username)
#         self.dashboard.show()
#         self.close()

#     def clear_enroll_fields(self):        
#         self.studFname.clear()
#         self.studMname.clear()
#         self.studLname.clear()
#         self.contact.clear()

#         self.motherName.clear()
#         self.fatherName.clear()
#         self.guardianName.clear()

#         # Reset dates to today (optional)
#         self.studDOB.setDate(QDate.currentDate())
#         self.motherDOB.setDate(QDate.currentDate())
#         self.fatherDOB.setDate(QDate.currentDate())
#         self.guardianDOB.setDate(QDate.currentDate())



#         # Reset combo box (Male/Female)
#         self.studSex.setCurrentIndex(0)

#         # Uncheck verification
#         self.verifyCheck.setChecked(False)



#     def load_guardians_table(self, studid):
#         from controller.GuardianController import GuardianController
#         gc = GuardianController()

#         data = gc.get_guardians_for_student(studid)
#         table = self.guardianTable
#         table.setRowCount(0)

#         for g in data:
#             row = table.rowCount()
#             table.insertRow(row)

#             table.setItem(row, 0, QTableWidgetItem(str(g["studid"])))
#             table.setItem(row, 1, QTableWidgetItem(g["guardianname"]))

#             # Actions
#             # action = QWidget()
#             # layout = QHBoxLayout(action)
#             # layout.setContentsMargins(0,0,0,0)

#             # edit_btn = QPushButton("Edit")
#             # delete_btn = QPushButton("Delete")

#             # edit_btn.clicked.connect(lambda _, guardian_id=g["guardianid"]: self.edit_guardian(guardian_id))
#             # delete_btn.clicked.connect(lambda _, id=g["guardianid"]: self.delete_guardian_record(id))

#             # layout.addWidget(edit_btn)
#             # layout.addWidget(delete_btn)
            
#             # view_btn = QPushButton("View")
#             # view_btn.clicked.connect(lambda _, guardian_id=g["guardianid"]: self.view_guardian_info(guardian_id))
#             # layout.addWidget(view_btn)

#             # table.setCellWidget(row, 2, action)
#             action = QWidget()
#             layout = QHBoxLayout(action)
#             layout.setContentsMargins(0, 0, 0, 0)
#             layout.setAlignment(Qt.AlignmentFlag.AlignCenter)   # ðŸ”¥ CENTER BUTTON

#             view_btn = QPushButton("View")
#             view_btn.setCursor(Qt.CursorShape.PointingHandCursor)

#             # Optional: match your style
#             view_btn.setStyleSheet("""
#                 QPushButton {
#                     border: none;
#                     background: transparent;
#                     color: #333;
#                 }
#                 QPushButton:hover {
#                     color: #8b2fdb;
#                 }
#             """)

#             view_btn.clicked.connect(lambda _, guardian_id=g["guardianid"]: self.view_guardian_info(guardian_id))
#             layout.addWidget(view_btn)

#             table.setCellWidget(row, 2, action)




#     def open_add_guardian_page(self):
#         self.newGuardianName.clear()
#         self.newGuardianDOB.setDate(QDate.currentDate())
#         self.newGuardianDOB.setCalendarPopup(True)


#         self.imgPlaceholder.clear()
#         self.current_guardian_image_path = None
#         self.current_guardian_encoding = None

#         self.stacked.setCurrentWidget(self.addGuardianPage)

            
    
#     def save_guardian(self):
#         name = self.newGuardianName.text().strip()
#         dob = self.newGuardianDOB.date().toString("yyyy-MM-dd")

#         if name == "":
#             QtWidgets.QMessageBox.warning(self, "Missing", "Guardian name is required.")
#             return

#         if self.current_guardian_encoding is None:
#             QtWidgets.QMessageBox.warning(self, "Missing", "Please scan the guardianâ€™s face.")
#             return

#         from controller.GuardianController import GuardianController
#         gc = GuardianController()

#         # Convert raw numpy â†’ bytea
#         encoding = gc.encode_face(self.current_guardian_encoding)

#         gc.insert_guardian(
#             studid=self.current_student_for_guardian,
#             name=name,
#             dob=dob,
#             image_path=self.current_guardian_image_path,
#             encoding=encoding
#         )

#         QtWidgets.QMessageBox.information(self, "Success", "Guardian added successfully!")

#         self.load_guardians_table(self.current_student_for_guardian)
#         self.stacked.setCurrentWidget(self.viewGuardianPage)


#     def delete_guardian_record(self, guardianid):
#         confirm = QtWidgets.QMessageBox.question(
#             self,
#             "Confirm",
#             "Delete this guardian?",
#             QtWidgets.QMessageBox.StandardButton.Yes | QtWidgets.QMessageBox.StandardButton.No
#         )

#         if confirm != QtWidgets.QMessageBox.StandardButton.Yes:
#             return

#         from controller.GuardianController import GuardianController
#         gc = GuardianController()
#         gc.delete_guardian(guardianid)

#         self.load_guardians_table(self.current_student_for_guardian)

    
#     def scan_guardian_face(self):
#         cam = CameraCapture()
#         if cam.exec() == QtWidgets.QDialog.DialogCode.Accepted:

#             folder = "uploads/guardians"
#             os.makedirs(folder, exist_ok=True)

#             safe_name = self.newGuardianName.text().strip().replace(" ", "_").lower()
#             unique = str(QDate.currentDate().toJulianDay()) + "_" + str(os.getpid())

#             filename = f"{self.current_student_for_guardian}_{safe_name}_{unique}.jpg"
#             filepath = os.path.join(folder, filename)

#             # SAVE IMAGE
#             cv2.imwrite(filepath, cam.captured_image)
#             self.current_guardian_image_path = filepath

#             # SAVE ENCODING (CORRECT: raw numpy array)
#             self.current_guardian_encoding = cam.captured_encoding   # ðŸ”¥ NOT .tolist()

#             # PREVIEW IMAGE
#             pixmap = QPixmap(filepath)
#             self.imgPlaceholder.setPixmap(
#                 pixmap.scaled(200, 200, Qt.AspectRatioMode.KeepAspectRatio)
#             )

#             QtWidgets.QMessageBox.information(self, "Success", "Face scanned successfully!")

#     def retake_guardian_face(self):
#         self.current_guardian_encoding = None

#         if self.current_guardian_image_path and os.path.exists(self.current_guardian_image_path):
#             os.remove(self.current_guardian_image_path)

#         self.current_guardian_image_path = None
#         self.imgPlaceholder.clear()

#         self.scan_guardian_face()  # reopen webcam


#     def delete_scanned_face(self):
#         self.current_guardian_encoding = None

#         if self.current_guardian_image_path and os.path.exists(self.current_guardian_image_path):
#             os.remove(self.current_guardian_image_path)

#         self.current_guardian_image_path = None
#         self.imgPlaceholder.clear()

#     def edit_guardian(self, guardian_id):
#         print("Editing Guardian:", guardian_id)

#         from controller.GuardianController import GuardianController
#         gc = GuardianController()

#         guardian = gc.get_guardian_by_id(guardian_id)
#         if guardian is None:
#             QtWidgets.QMessageBox.warning(self, "Error", "Guardian not found.")
#             return

#         # Store for saving later
#         self.current_edit_guardian_id = guardian_id

#         # Get edit page
#         page = self.editGuardianPage

#         # ==========================
#         # NAME FIELD
#         # ==========================
#         name_widget = page.findChild(QtWidgets.QLineEdit, "newGuardianNameInputEdit")
#         name_widget.setText(guardian["guardianname"])

#         # ==========================
#         # DOB FIELD
#         # ==========================
#         dob_widget = page.findChild(QtWidgets.QDateEdit, "newGuardianDOBInputEdit")
#         dob = guardian["guardiandob"]

#         if dob:
#             if isinstance(dob, str):
#                 dob_widget.setDate(QDate.fromString(dob, "yyyy-MM-dd"))
#             else:
#                 dob_widget.setDate(QDate(dob.year, dob.month, dob.day))
#         else:
#             dob_widget.setDate(dob_widget.minimumDate())

#         # ==========================
#         # PHOTO PREVIEW
#         # ==========================
#         img_lbl = page.findChild(QtWidgets.QLabel, "imgPlaceholderEdit")
#         image_path = guardian["face_image_path"]

#         self.current_guardian_encoding = guardian["face_encoding"]
#         self.current_guardian_image_path = image_path

#         if image_path and os.path.exists(image_path):
#             pixmap = QPixmap(image_path)
#             img_lbl.setPixmap(
#                 pixmap.scaled(200, 200, Qt.AspectRatioMode.KeepAspectRatio)
#             )
#         else:
#             img_lbl.clear()

#         # ==========================
#         # SWITCH PAGE
#         # ==========================
#         self.stacked.setCurrentWidget(self.editGuardianPage)
    
    
#     def save_edit_guardian(self):
#         from controller.GuardianController import GuardianController
#         gc = GuardianController()

#         guardian_id = self.current_edit_guardian_id

#         # ==========================
#         # GET WIDGETS
#         # ==========================
#         page = self.editGuardianPage
#         name_widget = page.findChild(QtWidgets.QLineEdit, "newGuardianNameInputEdit")
#         dob_widget = page.findChild(QtWidgets.QDateEdit, "newGuardianDOBInputEdit")
#         img_lbl = page.findChild(QtWidgets.QLabel, "imgPlaceholderEdit")

#         # ==========================
#         # READ INPUTS
#         # ==========================
#         name = name_widget.text().strip()
#         dob = dob_widget.date().toString("yyyy-MM-dd")

#         # ==========================
#         # VALIDATION
#         # ==========================
#         if name == "":
#             QtWidgets.QMessageBox.warning(self, "Missing", "Guardian name is required.")
#             return

#         # ==========================
#         # CONFIRM DIALOG
#         # ==========================
#         confirm = QtWidgets.QMessageBox.question(
#             self,
#             "Confirm Update",
#             "Are you sure you want to save guardian changes?",
#             QtWidgets.QMessageBox.StandardButton.Yes | QtWidgets.QMessageBox.StandardButton.No
#         )

#         if confirm != QtWidgets.QMessageBox.StandardButton.Yes:
#             return

#         # ==========================
#         # ENCODING HANDLING
#         # ==========================
#         # If user didn't rescan, keep DB encoding
#         encoding = None
#         if self.current_guardian_encoding is not None:
#             encoding = gc.encode_face(self.current_guardian_encoding)
#         else:
#             encoding = guardian_encoding = gc.get_guardian_by_id(guardian_id)["face_encoding"]

#         # ==========================
#         # IMAGE HANDLING
#         # ==========================
#         new_image_path = self.current_guardian_image_path

#         # If image changed â†’ delete the old one
#         old_record = gc.get_guardian_by_id(guardian_id)
#         old_path = old_record["face_image_path"]

#         if old_path and new_image_path and old_path != new_image_path:
#             if os.path.exists(old_path):
#                 os.remove(old_path)

#         # ==========================
#         # CALL UPDATE PROCEDURE
#         # ==========================
#         gc.update_guardian(
#             guardianid=guardian_id,
#             name=name,
#             dob=dob,
#             image_path=new_image_path,
#             encoding=encoding
#         )

#         # ==========================
#         # MESSAGE + REFRESH
#         # ==========================
#         QtWidgets.QMessageBox.information(self, "Success", "Guardian updated successfully!")

#         # Reload the guardians table for this student
#         self.load_guardians_table(self.current_student_for_guardian)

#         # Return to view page
#         self.stacked.setCurrentWidget(self.viewGuardianPage)


        
        
        
#     def view_guardian_info(self, guardian_id):
#         print("Viewing Guardian:", guardian_id)

#         from controller.GuardianController import GuardianController
#         gc = GuardianController()

#         guardian = gc.get_guardian_by_id(guardian_id)
#         if guardian is None:
#             QtWidgets.QMessageBox.warning(self, "Error", "Guardian not found.")
#             return

#         # Save for deletion later
#         self.current_view_guardian_id = guardian_id

#         page = self.editGuardianPage  # still using same page

#         # --- DISPLAY NAME ---
#         name_lbl = page.findChild(QtWidgets.QLabel, "guardianNameDisplay")
#         name_lbl.setText(guardian["guardianname"])

#         # --- DISPLAY DOB ---
#         dob_lbl = page.findChild(QtWidgets.QLabel, "guardianDOBDisplay")
#         dob = guardian["guardiandob"]
#         if dob:
#             if isinstance(dob, str):
#                 dob_lbl.setText(dob)
#             else:
#                 dob_lbl.setText(f"{dob.year}-{dob.month:02d}-{dob.day:02d}")
#         else:
#             dob_lbl.setText("No date available")

#         # --- DISPLAY PHOTO ---
#         img_lbl = page.findChild(QtWidgets.QLabel, "imgPlaceholderDisplay")

#         image_path = guardian["face_image_path"]
#         self.current_guardian_image_path = image_path  # for deletion

#         if image_path and os.path.exists(image_path):
#             pixmap = QPixmap(image_path)
#             img_lbl.setPixmap(
#                 pixmap.scaled(220, 220, Qt.AspectRatioMode.KeepAspectRatio)
#             )
#         else:
#             img_lbl.clear()

#         # --- GO TO VIEW PAGE ---
#         self.stacked.setCurrentWidget(self.editGuardianPage)
    
#     def delete_guardian_view(self):
#         guardian_id = self.current_view_guardian_id

#         confirm = QtWidgets.QMessageBox.question(
#             self,
#             "Confirm Delete",
#             "Are you sure you want to delete this guardian?",
#             QtWidgets.QMessageBox.StandardButton.Yes |
#             QtWidgets.QMessageBox.StandardButton.No
#         )

#         if confirm != QtWidgets.QMessageBox.StandardButton.Yes:
#             return

#         from controller.GuardianController import GuardianController
#         gc = GuardianController()

#         # Delete DB entry
#         gc.delete_guardian(guardian_id)

#         # Delete image if exists
#         if hasattr(self, "current_guardian_image_path") and \
#             self.current_guardian_image_path and \
#             os.path.exists(self.current_guardian_image_path):

#             os.remove(self.current_guardian_image_path)

#         QtWidgets.QMessageBox.information(self, "Deleted", "Guardian deleted successfully.")

#         # Refresh table
#         self.load_guardians_table(self.current_student_for_guardian)

#         # Go back
#         self.stacked.setCurrentWidget(self.viewGuardianPage)

        
# class CameraCapture(QDialog):
#     def __init__(self):
#         super().__init__()
#         self.setWindowTitle("Scan Guardian Face")
#         self.resize(600, 500)

#         self.video_label = QLabel()
#         self.video_label.setFixedSize(560, 420)

#         self.capture_btn = QPushButton("Capture")
#         self.capture_btn.clicked.connect(self.capture_frame)

#         layout = QVBoxLayout()
#         layout.addWidget(self.video_label)
#         layout.addWidget(self.capture_btn)
#         self.setLayout(layout)

#         self.cap = self.initialize_camera()

#         self.timer = QTimer()
#         self.timer.timeout.connect(self.update_frame)
#         self.timer.start(20)

#         self.captured_encoding = None
#         self.captured_image = None

#     def update_frame(self):
#         ret, frame = self.cap.read()
#         if not ret:
#             return

#         rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
#         h, w, ch = rgb.shape
#         qimg = QImage(rgb.data, w, h, ch * w, QImage.Format.Format_RGB888)
#         self.video_label.setPixmap(QPixmap.fromImage(qimg))

#         self.current_frame = frame

#     def capture_frame(self):
#         frame = self.current_frame
#         rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
#         locations = face_recognition.face_locations(rgb)

#         if len(locations) == 0:
#             QtWidgets.QMessageBox.warning(self, "No Face", "No face detected. Try again.")
#             return

#         encoding = face_recognition.face_encodings(rgb, locations)[0]
#         self.captured_encoding = encoding
#         self.captured_image = frame

#         self.accept()

#     def closeEvent(self, event):
#         self.cap.release()
#         self.timer.stop()
#         event.accept()
    
#     def initialize_camera(self):
#         import platform

#         system = platform.system()
#         possible_indexes = [0, 1, 2, 3]

#         for index in possible_indexes:

#             # ---- Select best backend based on OS ----
#             if system == "Windows":
#                 cap = cv2.VideoCapture(index, cv2.CAP_DSHOW)

#             elif system == "Darwin":  # macOS
#                 cap = cv2.VideoCapture(index, cv2.CAP_AVFOUNDATION)

#             else:  # Linux
#                 cap = cv2.VideoCapture(index)

#             # ---- Set resolution ----
#             cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
#             cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)

#             # ---- Test if camera works ----
#             if cap.isOpened():
#                 ret, frame = cap.read()
#                 if ret:
#                     print(f"Camera Activated â†’ index {index} | {system}")
#                     return cap

#             cap.release()

#         raise RuntimeError("No working camera found")

    

import cv2
import face_recognition
from PyQt6.QtWidgets import QDialog, QLabel, QVBoxLayout
from PyQt6.QtGui import QImage, QPixmap
from PyQt6.QtCore import QTimer, Qt, QDate
import os
from os import path
from PyQt6 import QtWidgets, uic
from PyQt6.QtWidgets import QWidget, QHBoxLayout, QPushButton, QTableWidgetItem

from controller.StudentController import StudentController

BASE_DIR = path.dirname(path.abspath(__file__))
PROJECT_ROOT = path.abspath(path.join(BASE_DIR, ".."))

UI_FILE = path.join(PROJECT_ROOT, "ui", "student.ui")
BG_FILE = path.join(PROJECT_ROOT, "assets", "images", "bg1.png")


class StudentWindow(QtWidgets.QMainWindow):
    def __init__(self, username):
        super().__init__()
        self.username = username
        self.controller = StudentController()

        uic.loadUi(UI_FILE, self)
        self.resize(1250, 800)

        # --- center window ---
        screen = QtWidgets.QApplication.primaryScreen().availableGeometry()
        win = self.frameGeometry()
        win.moveCenter(screen.center())
        self.move(win.topLeft())

        # Background
        cw = self.findChild(QtWidgets.QWidget, "centralwidget")
        self._bg_label = QtWidgets.QLabel(cw)
        self._bg_pix = QPixmap(BG_FILE)
        self._bg_label.setPixmap(self._bg_pix)
        self._bg_label.setScaledContents(True)
        self._bg_label.lower()
        self._bg_label.resize(cw.size())

        # Search bar
        self.searchStudent = self.findChild(QtWidgets.QLineEdit, "searchStudent")
        if self.searchStudent:
            self.searchStudent.textChanged.connect(self.apply_search)

        # Stacked pages
        self.stacked = self.findChild(QtWidgets.QStackedWidget, "stackedWidget")
        self.mainStudentPage = self.findChild(QtWidgets.QWidget, "mainStudentPage")
        self.enrollStudentPage = self.findChild(QtWidgets.QWidget, "enrollStudentPage")
        self.verificationPage = self.findChild(QtWidgets.QWidget, "verificationPage")
        self.confirmationPage = self.findChild(QtWidgets.QWidget, "confirmationPage")
        self.editStudentPage = self.findChild(QtWidgets.QWidget, "editStudentPage")
        self.viewGuardianPage = self.findChild(QtWidgets.QWidget, "viewGuardianPage")
        self.addGuardianPage = self.findChild(QtWidgets.QWidget, "addGuardianPage")
        self.editGuardianPage = self.findChild(QtWidgets.QWidget, "editGuardianPage")

        self.stacked.setCurrentWidget(self.mainStudentPage)

        # Buttons
        btn = self.findChild(QtWidgets.QPushButton, "enrollStudBtn")
        if btn:
            btn.clicked.connect(self.open_enroll_page)

        save_btn = self.findChild(QtWidgets.QPushButton, "saveEditBtn")
        if save_btn:
            save_btn.clicked.connect(self.save_student_changes)

        btn = self.findChild(QtWidgets.QPushButton, "backToDashboardBtn")
        if btn:
            btn.clicked.connect(self.go_to_dashboard)

        for name in ["backToMainBtn", "backToMainBtn_2", "backToMainBtn_3", "goBacktoDasboardBtn"]:
            btn = self.findChild(QtWidgets.QPushButton, name)
            if btn:
                btn.clicked.connect(lambda _, p=self.mainStudentPage: self.stacked.setCurrentWidget(p))

        btn = self.findChild(QtWidgets.QPushButton, "enrollBtn")
        if btn:
            btn.clicked.connect(self.validate_enroll_inputs)

        btn = self.findChild(QtWidgets.QPushButton, "backToInputBtn")
        if btn:
            btn.clicked.connect(lambda: self.stacked.setCurrentWidget(self.enrollStudentPage))

        btn = self.findChild(QtWidgets.QPushButton, "confirmBtn")
        if btn:
            btn.clicked.connect(self.finish_enrollment)

        delete_view_btn = self.findChild(QtWidgets.QPushButton, "deleteBtn_2")
        if delete_view_btn:
            delete_view_btn.clicked.connect(self.delete_guardian_view)

        back_view_btn = self.findChild(QtWidgets.QPushButton, "backToViewGuardianBtn")
        if back_view_btn:
            back_view_btn.clicked.connect(lambda: self.stacked.setCurrentWidget(self.viewGuardianPage))

        self.scanFaceBtn = self.findChild(QtWidgets.QPushButton, "scanFaceBtn")
        self.retakeBtn = self.findChild(QtWidgets.QPushButton, "retakeBtn")
        self.deleteBtn = self.findChild(QtWidgets.QPushButton, "deleteBtn")

        self.addGuardianBtn = self.findChild(QtWidgets.QPushButton, "addGuardianBtn")
        self.addSaveBtn = self.findChild(QtWidgets.QPushButton, "addSaveBtn")

        self.scanFaceBtn.clicked.connect(self.scan_guardian_face)
        self.retakeBtn.clicked.connect(self.retake_guardian_face)
        self.deleteBtn.clicked.connect(self.delete_scanned_face)
        self.addGuardianBtn.clicked.connect(self.open_add_guardian_page)
        self.addSaveBtn.clicked.connect(self.save_guardian)

        save_edit_btn = self.findChild(QtWidgets.QPushButton, "saveEditBtn_2")
        if save_edit_btn:
            save_edit_btn.clicked.connect(self.save_edit_guardian)

        guardian_routes = [
            ("addBtn", self.addGuardianPage),
            ("addGuardianBtn", self.addGuardianPage),
            ("backToViewGuardianBtn_2", self.viewGuardianPage),
        ]
        for name, page in guardian_routes:
            btn = self.findChild(QtWidgets.QPushButton, name)
            if btn:
                btn.clicked.connect(lambda _, p=page: self.stacked.setCurrentWidget(p))

        # Tables
        self.studentTable = self.findChild(QtWidgets.QTableWidget, "studentTable")
        self.setup_table(self.studentTable)

        self.guardianTable = self.findChild(QtWidgets.QTableWidget, "guardianTable")
        if self.guardianTable:
            self.setup_table(self.guardianTable)

        self.studentNameDisplay = self.findChild(QtWidgets.QLabel, "studentNameDisplay")

        # Inputs
        self.studIDLabel = self.findChild(QtWidgets.QLabel, "studIDLabel")
        self.studFname = self.findChild(QtWidgets.QLineEdit, "studFnameInput")
        self.studMname = self.findChild(QtWidgets.QLineEdit, "studMnameInput")
        self.studLname = self.findChild(QtWidgets.QLineEdit, "studLnameInput")
        self.studDOB = self.findChild(QtWidgets.QDateEdit, "studDOBInput")
        self.studSex = self.findChild(QtWidgets.QComboBox, "studSexInput")
        self.contact = self.findChild(QtWidgets.QLineEdit, "contactInput")

        self.motherName = self.findChild(QtWidgets.QLineEdit, "motherNameInput")
        self.motherDOB = self.findChild(QtWidgets.QDateEdit, "motherDOBInput")
        self.fatherName = self.findChild(QtWidgets.QLineEdit, "fatherNameInput")
        self.fatherDOB = self.findChild(QtWidgets.QDateEdit, "fatherDOBInput")
        self.guardianName = self.findChild(QtWidgets.QLineEdit, "guardianNameInput")
        self.guardianDOB = self.findChild(QtWidgets.QDateEdit, "guardianDOBInput")

        self.guardianDOBEdit = self.findChild(QtWidgets.QDateEdit, "guardianDOBEdit")
        self.guardianDOBEdit.setSpecialValueText("")
        self.guardianDOBEdit.setDate(self.guardianDOBEdit.minimumDate())

        self.verifyCheck = self.findChild(QtWidgets.QCheckBox, "verifyCheck")
        self.confirmLabel = self.findChild(QtWidgets.QLabel, "confirmLabel")

        # Guardian fields
        self.newGuardianName = self.findChild(QtWidgets.QLineEdit, "newGuardianNameInput")
        self.newGuardianDOB = self.findChild(QtWidgets.QDateEdit, "newGuardianDOBInput")
        self.imgPlaceholder = self.findChild(QtWidgets.QLabel, "imgPlaceholder")

        self.current_student_for_guardian = None
        self.current_guardian_image_path = None
        self.current_guardian_encoding = None

        self.load_students()

    def resizeEvent(self, event):
        super().resizeEvent(event)
        if hasattr(self, "_bg_label") and hasattr(self, "_bg_pix"):
            cw = self.findChild(QtWidgets.QWidget, "centralwidget")
            scaled = self._bg_pix.scaled(
                cw.size(),
                Qt.AspectRatioMode.KeepAspectRatioByExpanding,
                Qt.TransformationMode.SmoothTransformation
            )
            self._bg_label.setPixmap(scaled)
            self._bg_label.resize(cw.size())

    def setup_table(self, table):
        header = table.horizontalHeader()
        header.setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeMode.Interactive)
        header.setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeMode.Stretch)
        header.setSectionResizeMode(2, QtWidgets.QHeaderView.ResizeMode.Interactive)

        table.setColumnWidth(0, 150)
        table.setColumnWidth(2, 350)

        table.verticalHeader().setDefaultSectionSize(54)
        table.horizontalHeader().setFixedHeight(48)
        table.verticalHeader().setVisible(False)

        font = table.font()
        font.setPointSize(15)
        table.setFont(font)

        last_col = table.columnCount() - 1
        if last_col >= 0:
            item = table.horizontalHeaderItem(last_col)
            if item:
                item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)

        table.setStyleSheet("""
        QTableWidget { gridline-color: transparent; border: none; }
        QTableWidget::item { border: none; padding: 8px; }
        QHeaderView::section { border: none; background: transparent; padding-left: 12px; }
        QHeaderView::section:last { padding-left: 0px; }
        """)

    def load_students(self):
        self.studentTable.setRowCount(0)
        students = self.controller.get_students(self.username)
        for s in students:
            fullname = f"{s['studlname']}, {s['studfname']} {s.get('studmname','')}"
            self.add_student_row(s["studid"], fullname)

    def add_student_row(self, student_id, name):
        row = self.studentTable.rowCount()
        self.studentTable.insertRow(row)

        id_item = QTableWidgetItem(student_id)
        id_item.setFlags(id_item.flags() ^ Qt.ItemFlag.ItemIsEditable)
        self.studentTable.setItem(row, 0, id_item)

        name_item = QTableWidgetItem(name)
        name_item.setFlags(name_item.flags() ^ Qt.ItemFlag.ItemIsEditable)
        self.studentTable.setItem(row, 1, name_item)

        action_cell = QWidget()
        layout = QHBoxLayout(action_cell)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        edit_btn = QPushButton("Edit")
        delete_btn = QPushButton("Delete")
        view_btn = QPushButton("View Guardian")

        for btn in (edit_btn, delete_btn, view_btn):
            btn.setCursor(Qt.CursorShape.PointingHandCursor)
            btn.setStyleSheet("""
                QPushButton {
                    border: none;
                    background: transparent;
                    color: #333;
                    font-size: 15px;
                }
                QPushButton:hover { color: #8b2fdb; }
            """)
            layout.addWidget(btn)

        edit_btn.clicked.connect(lambda _, sid=student_id: self.edit_student(sid))
        delete_btn.clicked.connect(lambda _, sid=student_id: self.delete_student(sid))
        view_btn.clicked.connect(lambda _, sid=student_id: self.view_guardian(sid))

        self.studentTable.setCellWidget(row, 2, action_cell)

    # def edit_student(self, studID):
    #     student = self.controller.get_student(studID)
    #     if not student:
    #         QtWidgets.QMessageBox.warning(self, "Error", "Student not found.")
    #         return
    
    def edit_student(self, studID):
        student = self.controller.get_student(self.username, studID)
        if not student:
            QtWidgets.QMessageBox.warning(self, "Error", "Student not found.")
            return

        self.current_edit_id = studID


        self.findChild(QtWidgets.QLineEdit, "studFnameEdit").setText(student["studfname"])
        self.findChild(QtWidgets.QLineEdit, "studMnameEdit").setText(student["studmname"] or "")
        self.findChild(QtWidgets.QLineEdit, "studLnameEdit").setText(student["studlname"])
        self.findChild(QtWidgets.QLineEdit, "contactInputEdit").setText(student["studcontact"])
        self.findChild(QtWidgets.QComboBox, "studSexEdit").setCurrentText(student["studsex"])

        self.set_safe_date("studDOBEdit", student["studdob"])
        self.set_safe_date("motherDOBEdit", student["motherdob"])
        self.set_safe_date("fatherDOBEdit", student["fatherdob"])
        self.set_safe_date("guardianDOBEdit", student["guardiandob"])

        self.findChild(QtWidgets.QLineEdit, "motherNameEdit").setText(student["mothername"] or "")
        self.findChild(QtWidgets.QLineEdit, "fatherNameEdit").setText(student["fathername"] or "")
        self.findChild(QtWidgets.QLineEdit, "guardianNameEdit").setText(student["guardianname"] or "")

        self.stacked.setCurrentWidget(self.editStudentPage)

    def set_safe_date(self, name, value):
        widget = self.findChild(QtWidgets.QDateEdit, name)
        if widget is None:
            return
        if value is None:
            widget.setDate(widget.minimumDate())
        else:
            widget.setDate(value)

    # def save_student_changes(self):
    #     fname = self.findChild(QtWidgets.QLineEdit, "studFnameEdit").text().strip()
    #     lname = self.findChild(QtWidgets.QLineEdit, "studLnameEdit").text().strip()
    #     contact = self.findChild(QtWidgets.QLineEdit, "contactInputEdit").text().strip()

    #     errors = []
    #     if fname == "":
    #         errors.append("â€¢ First name is required.")
    #     if lname == "":
    #         errors.append("â€¢ Last name is required.")
    #     if contact == "":
    #         errors.append("â€¢ Emergency contact is required.")

    #     if errors:
    #         QtWidgets.QMessageBox.warning(
    #             self,
    #             "Missing Required Fields",
    #             "Please complete:\n\n" + "\n".join(errors)
    #         )
    #         return

    #     confirm = QtWidgets.QMessageBox.question(
    #         self,
    #         "Confirm",
    #         "Save changes?",
    #         QtWidgets.QMessageBox.StandardButton.Yes | QtWidgets.QMessageBox.StandardButton.No
    #     )
    #     if confirm != QtWidgets.QMessageBox.StandardButton.Yes:
    #         return

    #     data = {
    #         "studID": self.current_edit_id,
    #         "studFname": fname,
    #         "studMname": self.findChild(QtWidgets.QLineEdit, "studMnameEdit").text(),
    #         "studLname": lname,
    #         "studDOB": self.get_safe_date("studDOBEdit"),
    #         "studSex": self.findChild(QtWidgets.QComboBox, "studSexEdit").currentText(),
    #         "studContact": contact,

    #         "motherName": self.findChild(QtWidgets.QLineEdit, "motherNameEdit").text(),
    #         "motherDOB": self.get_safe_date("motherDOBEdit"),

    #         "fatherName": self.findChild(QtWidgets.QLineEdit, "fatherNameEdit").text(),
    #         "fatherDOB": self.get_safe_date("fatherDOBEdit"),

    #         "guardianName": self.findChild(QtWidgets.QLineEdit, "guardianNameEdit").text(),
    #         "guardianDOB": self.get_safe_date("guardianDOBEdit"),
    #     }

    #     self.controller.update_student(data)
    #     QtWidgets.QMessageBox.information(self, "Success", "Student updated successfully!")
    #     self.load_students()
    #     self.stacked.setCurrentWidget(self.mainStudentPage)



    def save_student_changes(self):
        fname = self.findChild(QtWidgets.QLineEdit, "studFnameEdit").text().strip()
        lname = self.findChild(QtWidgets.QLineEdit, "studLnameEdit").text().strip()
        contact = self.findChild(QtWidgets.QLineEdit, "contactInputEdit").text().strip()

        errors = []
        if fname == "":
            errors.append("â€¢ First name is required.")
        if lname == "":
            errors.append("â€¢ Last name is required.")
        if contact == "":
            errors.append("â€¢ Emergency contact is required.")

        if errors:
            QtWidgets.QMessageBox.warning(
                self,
                "Missing Required Fields",
                "Please complete:\n\n" + "\n".join(errors)
            )
            return

        confirm = QtWidgets.QMessageBox.question(
            self,
            "Confirm",
            "Save changes?",
            QtWidgets.QMessageBox.StandardButton.Yes | QtWidgets.QMessageBox.StandardButton.No
        )
        if confirm != QtWidgets.QMessageBox.StandardButton.Yes:
            return

        data = {
            "username": self.username,   # âœ… NEW
            "studID": self.current_edit_id,
            "studFname": fname,
            "studMname": self.findChild(QtWidgets.QLineEdit, "studMnameEdit").text(),
            "studLname": lname,
            "studDOB": self.get_safe_date("studDOBEdit"),
            "studSex": self.findChild(QtWidgets.QComboBox, "studSexEdit").currentText(),
            "studContact": contact,
            "motherName": self.findChild(QtWidgets.QLineEdit, "motherNameEdit").text(),
            "motherDOB": self.get_safe_date("motherDOBEdit"),
            "fatherName": self.findChild(QtWidgets.QLineEdit, "fatherNameEdit").text(),
            "fatherDOB": self.get_safe_date("fatherDOBEdit"),
            "guardianName": self.findChild(QtWidgets.QLineEdit, "guardianNameEdit").text(),
            "guardianDOB": self.get_safe_date("guardianDOBEdit"),
        }

        self.controller.update_student(data)
        QtWidgets.QMessageBox.information(self, "Success", "Student updated successfully!")
        self.load_students()
        self.stacked.setCurrentWidget(self.mainStudentPage)


    def get_safe_date(self, name):
        widget = self.findChild(QtWidgets.QDateEdit, name)
        if widget is None:
            return None

        date = widget.date()
        if date == widget.minimumDate():
            return None
        return date.toString("yyyy-MM-dd")

    # def delete_student(self, student_id):
    #     confirm = QtWidgets.QMessageBox.question(
    #         self,
    #         "Confirm Delete",
    #         f"Delete student {student_id}?\nThis also removes all guardians.",
    #         QtWidgets.QMessageBox.StandardButton.Yes |
    #         QtWidgets.QMessageBox.StandardButton.No
    #     )
    #     if confirm != QtWidgets.QMessageBox.StandardButton.Yes:
    #         return

    #     from controller.GuardianController import GuardianController
    #     gc = GuardianController()
    #     guardians = gc.get_guardians_for_student(student_id)

    #     for g in guardians:
    #         path = g["face_image_path"]
    #         if path and os.path.exists(path):
    #             os.remove(path)

    #     self.controller.delete_student(student_id)

    #     QtWidgets.QMessageBox.information(self, "Deleted", "Student & guardians deleted.")
    #     self.load_students()
    
    def delete_student(self, student_code):
        confirm = QtWidgets.QMessageBox.question(
            self,
            "Confirm Delete",
            f"Delete student {student_code}?\nThis also removes all guardians.",
            QtWidgets.QMessageBox.StandardButton.Yes |
            QtWidgets.QMessageBox.StandardButton.No
        )
        if confirm != QtWidgets.QMessageBox.StandardButton.Yes:
            return

        from controller.GuardianController import GuardianController
        gc = GuardianController()

        # map studid code â†’ studentid
        student = self.controller.get_student(self.username, student_code)
        if not student:
            QtWidgets.QMessageBox.warning(self, "Error", "Student not found.")
            return

        real_id = student["studentid"]
        guardians = gc.get_guardians_for_student(real_id)

        for g in guardians:
            path = g["face_image_path"]
            if path and os.path.exists(path):
                os.remove(path)

        self.controller.delete_student(self.username, student_code)

        QtWidgets.QMessageBox.information(self, "Deleted", "Student & guardians deleted.")
        self.load_students()


    # def view_guardian(self, studid):
    #     from controller.GuardianController import GuardianController
    #     self.current_student_for_guardian = studid

    #     student = self.controller.get_student(studid)
    #     full = f"{student['studlname']}, {student['studfname']} {student['studmname'] or ''}"
    #     self.studentNameDisplay.setText(full)

    #     self.load_guardians_table(studid)
    #     self.stacked.setCurrentWidget(self.viewGuardianPage)


    def view_guardian(self, studid):
        from controller.GuardianController import GuardianController
        self.current_student_for_guardian = studid  # studid code (S001)

        student = self.controller.get_student(self.username, studid)
        full = f"{student['studlname']}, {student['studfname']} {student['studmname'] or ''}"
        self.studentNameDisplay.setText(full)

        self.load_guardians_table(studid)
        self.stacked.setCurrentWidget(self.viewGuardianPage)


    def open_enroll_page(self):
        self.clear_enroll_fields()
        new_id = self.controller.generate_student_id(self.username)
        self.studIDLabel.setText(new_id)
        self.stacked.setCurrentWidget(self.enrollStudentPage)

    # def finish_enrollment(self):
    #     if not self.verifyCheck.isChecked():
    #         QtWidgets.QMessageBox.warning(self, "Error", "Please confirm verification.")
    #         return

    #     data = {
    #         "username": self.username,
    #         "studID": self.studIDLabel.text(),
    #         "studLname": self.studLname.text(),
    #         "studFname": self.studFname.text(),
    #         "studMname": self.studMname.text(),
    #         "studDOB": self.studDOB.text(),
    #         "studSex": self.studSex.currentText(),
    #         "studContact": self.contact.text(),
    #         "motherName": self.motherName.text(),
    #         "motherDOB": None if self.motherName.text().strip() == "" else self.motherDOB.date().toString("yyyy-MM-dd"),
    #         "fatherName": self.fatherName.text(),
    #         "fatherDOB": None if self.fatherName.text().strip() == "" else self.fatherDOB.date().toString("yyyy-MM-dd"),
    #         "guardianName": self.guardianName.text(),
    #         "guardianDOB": None if self.guardianName.text().strip() == "" else self.guardianDOB.text(),
    #     }

    #     self.controller.insert_student(self.username, data)

    #     self.confirmLabel.setText(
    #         f"Student {data['studLname']}, {data['studFname']} {data['studMname']} "
    #         f"({data['studID']}) has been successfully enrolled."
    #     )

    #     self.stacked.setCurrentWidget(self.confirmationPage)
    #     self.load_students()



    def finish_enrollment(self):
        if not self.verifyCheck.isChecked():
            QtWidgets.QMessageBox.warning(self, "Error", "Please confirm verification.")
            return

        data = {
            "username": self.username,   # âœ… IMPORTANT
            "studID": self.studIDLabel.text(),
            "studLname": self.studLname.text(),
            "studFname": self.studFname.text(),
            "studMname": self.studMname.text(),
            "studDOB": self.studDOB.text(),
            "studSex": self.studSex.currentText(),
            "studContact": self.contact.text(),
            "motherName": self.motherName.text(),
            "motherDOB": None if self.motherName.text().strip() == "" else self.motherDOB.date().toString("yyyy-MM-dd"),
            "fatherName": self.fatherName.text(),
            "fatherDOB": None if self.fatherName.text().strip() == "" else self.fatherDOB.date().toString("yyyy-MM-dd"),
            "guardianName": self.guardianName.text(),
            "guardianDOB": None if self.guardianName.text().strip() == "" else self.guardianDOB.text(),
        }

        self.controller.insert_student(data)

        self.confirmLabel.setText(
            f"Student {data['studLname']}, {data['studFname']} {data['studMname']} "
            f"({data['studID']}) has been successfully enrolled."
        )

        self.stacked.setCurrentWidget(self.confirmationPage)
        self.load_students()


    def validate_enroll_inputs(self):
        fname = self.studFname.text().strip()
        lname = self.studLname.text().strip()
        contact = self.contact.text().strip()

        errors = []
        if fname == "":
            errors.append("â€¢ First name is required.")
        if lname == "":
            errors.append("â€¢ Last name is required.")
        if contact == "":
            errors.append("â€¢ Contact / emergency contact is required.")

        if errors:
            QtWidgets.QMessageBox.warning(
                self,
                "Missing Required Fields",
                "Please fill in:\n\n" + "\n".join(errors)
            )
            return

        self.stacked.setCurrentWidget(self.verificationPage)

    def apply_search(self):
        search = self.searchStudent.text().strip().lower()
        self.studentTable.setRowCount(0)

        students = self.controller.search_students(self.username, search)
        for s in students:
            fullname = f"{s['studlname']}, {s['studfname']} {s.get('studmname','')}"
            self.add_student_row(s["studid"], fullname)

    def go_to_dashboard(self):
        from views.dashboard import AdminWindow
        self.dashboard = AdminWindow(self.username)
        self.dashboard.show()
        self.close()

    def clear_enroll_fields(self):
        self.studFname.clear()
        self.studMname.clear()
        self.studLname.clear()
        self.contact.clear()
        self.motherName.clear()
        self.fatherName.clear()
        self.guardianName.clear()

        self.studDOB.setDate(QDate.currentDate())
        self.motherDOB.setDate(QDate.currentDate())
        self.fatherDOB.setDate(QDate.currentDate())
        self.guardianDOB.setDate(QDate.currentDate())

        self.studSex.setCurrentIndex(0)
        self.verifyCheck.setChecked(False)

    # def load_guardians_table(self, studid):
    #     from controller.GuardianController import GuardianController
    #     gc = GuardianController()

    #     # data = gc.get_guardians_for_student(studid)
    #     student = self.controller.get_student(studid)
    #     real_id = student["studentid"]          # numeric primary key
    #     data = gc.get_guardians_for_student(real_id)

    #     table = self.guardianTable
    #     table.setRowCount(0)

    #     for g in data:
    #         row = table.rowCount()
    #         table.insertRow(row)

    #         # FIXED: studid â†’ studentid
    #         table.setItem(row, 0, QTableWidgetItem(str(g["studentid"])))
    #         table.setItem(row, 1, QTableWidgetItem(g["guardianname"]))

    #         action = QWidget()
    #         layout = QHBoxLayout(action)
    #         layout.setContentsMargins(0, 0, 0, 0)
    #         layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

    #         view_btn = QPushButton("View")
    #         view_btn.setCursor(Qt.CursorShape.PointingHandCursor)
    #         view_btn.setStyleSheet("""
    #             QPushButton { border: none; background: transparent; color: #333; }
    #             QPushButton:hover { color: #8b2fdb; }
    #         """)
    #         view_btn.clicked.connect(lambda _, guardian_id=g["guardianid"]: self.view_guardian_info(guardian_id))
    #         layout.addWidget(view_btn)

    #         table.setCellWidget(row, 2, action)


    def load_guardians_table(self, studid):
        from controller.GuardianController import GuardianController
        gc = GuardianController()

        # get real primary key (studentid int) using username + studid
        student = self.controller.get_student(self.username, studid)
        if not student:
            return

        real_id = student["studentid"]
        data = gc.get_guardians_for_student(real_id)

        table = self.guardianTable
        table.setRowCount(0)

        for g in data:
            row = table.rowCount()
            table.insertRow(row)

            # show STUDID code (S001, S002...) not numeric studentid
            table.setItem(row, 0, QTableWidgetItem(str(g["studid"])))
            table.setItem(row, 1, QTableWidgetItem(g["guardianname"]))

            action = QWidget()
            layout = QHBoxLayout(action)
            layout.setContentsMargins(0, 0, 0, 0)
            layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

            view_btn = QPushButton("View")
            view_btn.setCursor(Qt.CursorShape.PointingHandCursor)
            view_btn.setStyleSheet("""
                QPushButton { border: none; background: transparent; color: #333; font-size: 15px;}
                QPushButton:hover { color: #8b2fdb; }
            """)
            view_btn.clicked.connect(
                lambda _, guardian_id=g["guardianid"]: self.view_guardian_info(guardian_id)
            )
            layout.addWidget(view_btn)

            table.setCellWidget(row, 2, action)


    def open_add_guardian_page(self):
        self.newGuardianName.clear()
        self.newGuardianDOB.setDate(QDate.currentDate())
        self.newGuardianDOB.setCalendarPopup(True)

        self.imgPlaceholder.clear()
        self.current_guardian_image_path = None
        self.current_guardian_encoding = None

        self.stacked.setCurrentWidget(self.addGuardianPage)

    # def save_guardian(self):
    #     name = self.newGuardianName.text().strip()
    #     dob = self.newGuardianDOB.date().toString("yyyy-MM-dd")

    #     if name == "":
    #         QtWidgets.QMessageBox.warning(self, "Missing", "Guardian name is required.")
    #         return

    #     if self.current_guardian_encoding is None:
    #         QtWidgets.QMessageBox.warning(self, "Missing", "Please scan the guardianâ€™s face.")
    #         return

    #     from controller.GuardianController import GuardianController
    #     gc = GuardianController()

    #     encoding = gc.encode_face(self.current_guardian_encoding)

    #     gc.insert_guardian(
    #         studid=self.current_student_for_guardian,
    #         name=name,
    #         dob=dob,
    #         image_path=self.current_guardian_image_path,
    #         encoding=encoding
    #     )

    #     QtWidgets.QMessageBox.information(self, "Success", "Guardian added successfully!")
    #     self.load_guardians_table(self.current_student_for_guardian)
    #     self.stacked.setCurrentWidget(self.viewGuardianPage)
    
    
    
    def save_guardian(self):
        name = self.newGuardianName.text().strip()
        dob = self.newGuardianDOB.date().toString("yyyy-MM-dd")

        if name == "":
            QtWidgets.QMessageBox.warning(self, "Missing", "Guardian name is required.")
            return

        if self.current_guardian_encoding is None:
            QtWidgets.QMessageBox.warning(self, "Missing", "Please scan the guardianâ€™s face.")
            return

        from controller.GuardianController import GuardianController
        gc = GuardianController()

        encoding = gc.encode_face(self.current_guardian_encoding)

        # map current_student_for_guardian (studid code) â†’ studentid
        student = self.controller.get_student(self.username, self.current_student_for_guardian)
        if not student:
            QtWidgets.QMessageBox.warning(self, "Error", "Student not found.")
            return

        real_id = student["studentid"]

        gc.insert_guardian(
            studentid=real_id,
            name=name,
            dob=dob,
            image_path=self.current_guardian_image_path,
            encoding=encoding
        )

        QtWidgets.QMessageBox.information(self, "Success", "Guardian added successfully!")
        self.load_guardians_table(self.current_student_for_guardian)
        self.stacked.setCurrentWidget(self.viewGuardianPage)


    def delete_guardian_record(self, guardianid):
        confirm = QtWidgets.QMessageBox.question(
            self, "Confirm", "Delete this guardian?",
            QtWidgets.QMessageBox.StandardButton.Yes | QtWidgets.QMessageBox.StandardButton.No
        )
        if confirm != QtWidgets.QMessageBox.StandardButton.Yes:
            return

        from controller.GuardianController import GuardianController
        gc = GuardianController()
        gc.delete_guardian(guardianid)
        self.load_guardians_table(self.current_student_for_guardian)


    def scan_guardian_face(self):
        cam = CameraCapture()
        if cam.exec() == QtWidgets.QDialog.DialogCode.Accepted:

            folder = "uploads/guardians"
            os.makedirs(folder, exist_ok=True)

            safe_name = self.newGuardianName.text().strip().replace(" ", "_").lower()
            unique = str(QDate.currentDate().toJulianDay()) + "_" + str(os.getpid())
            filename = f"{self.current_student_for_guardian}_{safe_name}_{unique}.jpg"
            filepath = os.path.join(folder, filename)

            cv2.imwrite(filepath, cam.captured_image)
            self.current_guardian_image_path = filepath
            self.current_guardian_encoding = cam.captured_encoding

            pixmap = QPixmap(filepath)
            self.imgPlaceholder.setPixmap(
                pixmap.scaled(200, 200, Qt.AspectRatioMode.KeepAspectRatio)
            )

            QtWidgets.QMessageBox.information(self, "Success", "Face scanned successfully!")

    def retake_guardian_face(self):
        self.current_guardian_encoding = None

        if self.current_guardian_image_path and os.path.exists(self.current_guardian_image_path):
            os.remove(self.current_guardian_image_path)

        self.current_guardian_image_path = None
        self.imgPlaceholder.clear()

        self.scan_guardian_face()

    def delete_scanned_face(self):
        self.current_guardian_encoding = None

        if self.current_guardian_image_path and os.path.exists(self.current_guardian_image_path):
            os.remove(self.current_guardian_image_path)

        self.current_guardian_image_path = None
        self.imgPlaceholder.clear()

    def edit_guardian(self, guardian_id):
        from controller.GuardianController import GuardianController
        gc = GuardianController()

        guardian = gc.get_guardian_by_id(guardian_id)
        if guardian is None:
            QtWidgets.QMessageBox.warning(self, "Error", "Guardian not found.")
            return

        self.current_edit_guardian_id = guardian_id
        page = self.editGuardianPage

        name_widget = page.findChild(QtWidgets.QLineEdit, "newGuardianNameInputEdit")
        name_widget.setText(guardian["guardianname"])

        dob_widget = page.findChild(QtWidgets.QDateEdit, "newGuardianDOBInputEdit")
        dob = guardian["guardiandob"]
        if dob:
            if isinstance(dob, str):
                dob_widget.setDate(QDate.fromString(dob, "yyyy-MM-dd"))
            else:
                dob_widget.setDate(QDate(dob.year, dob.month, dob.day))
        else:
            dob_widget.setDate(dob_widget.minimumDate())

        img_lbl = page.findChild(QtWidgets.QLabel, "imgPlaceholderEdit")
        image_path = guardian["face_image_path"]

        self.current_guardian_encoding = guardian["face_encoding"]
        self.current_guardian_image_path = image_path

        if image_path and os.path.exists(image_path):
            pixmap = QPixmap(image_path)
            img_lbl.setPixmap(
                pixmap.scaled(200, 200, Qt.AspectRatioMode.KeepAspectRatio)
            )
        else:
            img_lbl.clear()

        self.stacked.setCurrentWidget(self.editGuardianPage)

    def save_edit_guardian(self):
        from controller.GuardianController import GuardianController
        gc = GuardianController()

        guardian_id = self.current_edit_guardian_id
        page = self.editGuardianPage

        name_widget = page.findChild(QtWidgets.QLineEdit, "newGuardianNameInputEdit")
        dob_widget = page.findChild(QtWidgets.QDateEdit, "newGuardianDOBInputEdit")

        name = name_widget.text().strip()
        dob = dob_widget.date().toString("yyyy-MM-dd")

        if name == "":
            QtWidgets.QMessageBox.warning(self, "Missing", "Guardian name is required.")
            return

        confirm = QtWidgets.QMessageBox.question(
            self,
            "Confirm Update",
            "Save guardian changes?",
            QtWidgets.QMessageBox.StandardButton.Yes | QtWidgets.QMessageBox.StandardButton.No
        )
        if confirm != QtWidgets.QMessageBox.StandardButton.Yes:
            return

        if self.current_guardian_encoding is not None:
            encoding = gc.encode_face(self.current_guardian_encoding)
        else:
            encoding = gc.get_guardian_by_id(guardian_id)["face_encoding"]

        new_image_path = self.current_guardian_image_path
        old_record = gc.get_guardian_by_id(guardian_id)
        old_path = old_record["face_image_path"]

        if old_path and new_image_path and old_path != new_image_path:
            if os.path.exists(old_path):
                os.remove(old_path)

        gc.update_guardian(
            guardianid=guardian_id,
            name=name,
            dob=dob,
            image_path=new_image_path,
            encoding=encoding
        )

        QtWidgets.QMessageBox.information(self, "Success", "Guardian updated successfully!")
        self.load_guardians_table(self.current_student_for_guardian)
        self.stacked.setCurrentWidget(self.viewGuardianPage)

    def view_guardian_info(self, guardian_id):
        from controller.GuardianController import GuardianController
        gc = GuardianController()

        guardian = gc.get_guardian_by_id(guardian_id)
        if guardian is None:
            QtWidgets.QMessageBox.warning(self, "Error", "Guardian not found.")
            return

        self.current_view_guardian_id = guardian_id
        page = self.editGuardianPage

        name_lbl = page.findChild(QtWidgets.QLabel, "guardianNameDisplay")
        name_lbl.setText(guardian["guardianname"])

        dob_lbl = page.findChild(QtWidgets.QLabel, "guardianDOBDisplay")
        dob = guardian["guardiandob"]
        if dob:
            if isinstance(dob, str):
                dob_lbl.setText(dob)
            else:
                dob_lbl.setText(f"{dob.year}-{dob.month:02d}-{dob.day:02d}")
        else:
            dob_lbl.setText("No date available")

        img_lbl = page.findChild(QtWidgets.QLabel, "imgPlaceholderDisplay")
        image_path = guardian["face_image_path"]
        self.current_guardian_image_path = image_path

        if image_path and os.path.exists(image_path):
            pixmap = QPixmap(image_path)
            img_lbl.setPixmap(
                pixmap.scaled(220, 220, Qt.AspectRatioMode.KeepAspectRatio)
            )
        else:
            img_lbl.clear()

        self.stacked.setCurrentWidget(self.editGuardianPage)

    def delete_guardian_view(self):
        guardian_id = self.current_view_guardian_id

        confirm = QtWidgets.QMessageBox.question(
            self,
            "Confirm Delete",
            "Are you sure you want to delete this guardian?",
            QtWidgets.QMessageBox.StandardButton.Yes |
            QtWidgets.QMessageBox.StandardButton.No
        )
        if confirm != QtWidgets.QMessageBox.StandardButton.Yes:
            return

        from controller.GuardianController import GuardianController
        gc = GuardianController()
        gc.delete_guardian(guardian_id)

        if hasattr(self, "current_guardian_image_path") and \
            self.current_guardian_image_path and \
            os.path.exists(self.current_guardian_image_path):

            os.remove(self.current_guardian_image_path)

        QtWidgets.QMessageBox.information(self, "Deleted", "Guardian deleted successfully.")

        self.load_guardians_table(self.current_student_for_guardian)
        self.stacked.setCurrentWidget(self.viewGuardianPage)


class CameraCapture(QDialog):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Scan Guardian Face")
        self.resize(600, 500)

        self.video_label = QLabel()
        self.video_label.setFixedSize(560, 420)

        self.capture_btn = QPushButton("Capture")
        self.capture_btn.clicked.connect(self.capture_frame)

        layout = QVBoxLayout()
        layout.addWidget(self.video_label)
        layout.addWidget(self.capture_btn)
        self.setLayout(layout)

        self.cap = self.initialize_camera()

        self.timer = QTimer()
        self.timer.timeout.connect(self.update_frame)
        self.timer.start(20)

        self.captured_encoding = None
        self.captured_image = None

    # def update_frame(self):
    #     ret, frame = self.cap.read()
    #     if not ret:
    #         return

    #     rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    #     h, w, ch = rgb.shape
    #     qimg = QImage(rgb.data, w, h, ch * w, QImage.Format.Format_RGB888)
    #     self.video_label.setPixmap(QPixmap.fromImage(qimg))
        # self.current_frame = frame
    def update_frame(self):
        ret, frame = self.cap.read()
        if not ret:
            return

        self.raw_frame = frame  # <-- ORIGINAL frame (not flipped)

        # Flip only for UI preview
        display = cv2.flip(frame, 1)
        self.display_frame = display

        rgb = cv2.cvtColor(display, cv2.COLOR_BGR2RGB)
        h, w, ch = rgb.shape
        qimg = QImage(rgb.data, w, h, ch * w, QImage.Format.Format_RGB888)
        self.video_label.setPixmap(QPixmap.fromImage(qimg))

        

    # def capture_frame(self):
    #     frame = self.current_frame
    #     rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    #     locations = face_recognition.face_locations(rgb)

    #     if len(locations) == 0:
    #         QtWidgets.QMessageBox.warning(self, "No Face", "No face detected. Try again.")
    #         return

    #     encoding = face_recognition.face_encodings(rgb, locations)[0]
    #     self.captured_encoding = encoding
    #     self.captured_image = frame

    #     self.accept()
    def capture_frame(self):
        frame = self.raw_frame.copy()  # original feed (mirrored by Mac)
        
        rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        locations = face_recognition.face_locations(rgb)

        if not locations:
            QtWidgets.QMessageBox.warning(self, "No Face", "No face detected.")
            return

        self.captured_encoding = face_recognition.face_encodings(rgb, locations)[0]

        # ðŸ‘‡ Fix: unmirror the saved image
        self.captured_image = cv2.flip(frame, 1)

        self.accept()





    def closeEvent(self, event):
        self.cap.release()
        self.timer.stop()
        event.accept()

    def initialize_camera(self):
        import platform
        system = platform.system()
        possible_indexes = [0, 1, 2, 3]

        for index in possible_indexes:
            if system == "Windows":
                cap = cv2.VideoCapture(index, cv2.CAP_DSHOW)
            elif system == "Darwin":
                cap = cv2.VideoCapture(index, cv2.CAP_AVFOUNDATION)
            else:
                cap = cv2.VideoCapture(index)

            cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
            cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)

            if cap.isOpened():
                ret, frame = cap.read()
                if ret:
                    return cap

            cap.release()

        raise RuntimeError("No working camera found")





mode:
    
    
    
    # import sys
# from os import path

# from PyQt6 import QtWidgets, uic
# from PyQt6.QtCore import Qt


# BASE_DIR = path.dirname(path.abspath(__file__))
# PROJECT_ROOT = path.abspath(path.join(BASE_DIR, ".."))

# UI_FILE = path.join(PROJECT_ROOT, "ui", "mode.ui")


# class ChooseModeWindow(QtWidgets.QMainWindow):
#     def __init__(self):
#         super().__init__()

#         uic.loadUi(UI_FILE, self)

#         # ----------------------------
#         # Get widgets from UI
#         # ----------------------------
#         self.gateFrame = self.findChild(QtWidgets.QFrame, "gateFrame")
#         self.homeFrame = self.findChild(QtWidgets.QFrame, "homeFrame")

#         self.homeTopFrame = self.findChild(QtWidgets.QFrame, "frame_5")
#         self.homeExtraFrame = self.findChild(QtWidgets.QFrame, "frame_4")

#         self.gateBtn = self.findChild(QtWidgets.QPushButton, "gateBtn")
#         self.gateIconBtn = self.findChild(QtWidgets.QPushButton, "gateIconBtn")

#         self.homeBtn = self.findChild(QtWidgets.QPushButton, "homeBtn")
#         self.homeIconBtn = self.findChild(QtWidgets.QPushButton, "homeIconBtn")
#         self.exitBtn = self.findChild(QtWidgets.QPushButton, "exitBtn")

#         self.backBtn = self.findChild(QtWidgets.QPushButton, "backBtn")

#         self.home_expanded = False

#         # ----------------------------
#         # INITIAL CARD HEIGHTS
#         # ----------------------------
#         # ðŸ‘‰ both cards start at 400px height
#         for frame in (self.gateFrame, self.homeFrame):
#             if frame is not None:
#                 frame.setMinimumHeight(400)
#                 frame.setMaximumHeight(400)

#         # ----------------------------
#         # Connect signals
#         # ----------------------------

#         if self.homeBtn is not None:
#             self.homeBtn.clicked.connect(self.expand_home_card)

#         if self.homeIconBtn is not None:
#             self.homeIconBtn.clicked.connect(self.expand_home_card)

#         if self.exitBtn is not None:
#             self.exitBtn.clicked.connect(self.collapse_home_card)

#         if self.backBtn is not None:
#             self.backBtn.clicked.connect(self.close)

#         # Start collapsed
#         self.collapse_home_card()

#     # ------------------------------------------------------------------
#     def set_home_expanded(self, expanded: bool):
#         """Show/hide the extra Home widgets (pass input, forgot btn, etc.)."""
#         self.home_expanded = expanded

#         if self.homeExtraFrame is not None:
#             self.homeExtraFrame.setVisible(expanded)

#         if self.exitBtn is not None:
#             self.exitBtn.setVisible(expanded)

#         # HEIGHT LOGIC
#         if self.homeFrame is not None:
#             if expanded:
#                 # expanded: allow home card to grow taller than 400
#                 self.homeFrame.setMinimumHeight(400)    # base size
#                 self.homeFrame.setMaximumHeight(9999)   # no real limit
#             else:
#                 # collapsed: fixed 400 height
#                 self.homeFrame.setMinimumHeight(400)
#                 self.homeFrame.setMaximumHeight(400)

#         # gateFrame stays 400 all the time
#         if self.gateFrame is not None:
#             self.gateFrame.setMinimumHeight(400)
#             self.gateFrame.setMaximumHeight(400)

#     def expand_home_card(self):
#         self.set_home_expanded(True)

#     def collapse_home_card(self):
#         self.set_home_expanded(False)


# def main():
#     app = QtWidgets.QApplication(sys.argv)
#     win = ChooseModeWindow()
#     win.show()
#     sys.exit(app.exec())


# if __name__ == "__main__":
#     main()



import sys
from os import path
from PyQt6 import QtWidgets, uic, QtGui, QtCore

from controller.HomePassController import HomePassController
from controller.ForgotPasswordController import ForgotPasswordController


BASE_DIR = path.dirname(path.abspath(__file__))
PROJECT_ROOT = path.abspath(path.join(BASE_DIR, ".."))
UI_FILE = path.join(PROJECT_ROOT, "ui", "mode.ui")


class ChooseModeWindow(QtWidgets.QMainWindow):
    def __init__(self, username):
        super().__init__()
        self.username = username

        uic.loadUi(UI_FILE, self)
        
        
        self.resize(1250, 800)

        # --- center window ---
        screen = QtWidgets.QApplication.primaryScreen().availableGeometry()
        win = self.frameGeometry()
        win.moveCenter(screen.center())
        self.move(win.topLeft())

        # ============= CONTROLLERS =============
        self.home_ctrl = HomePassController()
        self.forgot_ctrl = ForgotPasswordController()

        # ============= UI WIDGETS =============
        self.gateFrame = self.findChild(QtWidgets.QFrame, "gateFrame")
        self.homeFrame = self.findChild(QtWidgets.QFrame, "homeFrame")
        self.homeTopFrame = self.findChild(QtWidgets.QFrame, "frame_5")
        self.homeExtraFrame = self.findChild(QtWidgets.QFrame, "frame_4")

        self.gateBtn = self.findChild(QtWidgets.QPushButton, "gateBtn")
        self.gateIconBtn = self.findChild(QtWidgets.QPushButton, "gateIconBtn")

        self.homeBtn = self.findChild(QtWidgets.QPushButton, "homeBtn")
        self.homeIconBtn = self.findChild(QtWidgets.QPushButton, "homeIconBtn")

        self.exitBtn = self.findChild(QtWidgets.QPushButton, "exitBtn")
        self.backBtn = self.findChild(QtWidgets.QPushButton, "backBtn")

        self.homePassInput = self.findChild(QtWidgets.QLineEdit, "homePassInput")
        self.forgotPassBtn = self.findChild(QtWidgets.QPushButton, "forgotPassBtn")

        # ============= STATES =============
        self.home_expanded = False

        # Start frames at 400px height
        for frame in (self.gateFrame, self.homeFrame):
            if frame:
                frame.setMinimumHeight(400)
                frame.setMaximumHeight(400)

        # ================= SIGNALS =================
        # HOME expand
        if self.homeBtn:
            self.homeBtn.clicked.connect(self.expand_home_card)

        if self.homeIconBtn:
            self.homeIconBtn.clicked.connect(self.expand_home_card)

        # HOME collapse
        if self.exitBtn:
            self.exitBtn.clicked.connect(self.collapse_home_card)

        self.backBtn.clicked.connect(self._on_back)


        # HOME PASS ENTER
        if self.homePassInput:
            self.homePassInput.returnPressed.connect(self._on_enter_home)

        # FORGOT PASS FLOW
        if self.forgotPassBtn:
            self.forgotPassBtn.clicked.connect(self._on_forgot_pass)

        # GATE MODE
        if self.gateBtn:
            self.gateBtn.clicked.connect(self._on_gate)

        if self.gateIconBtn:
            self.gateIconBtn.clicked.connect(self._on_gate)

        # Start collapsed
        self.collapse_home_card()

    # ------------------------------------------------------
    # HOME CARD SIZES
    # ------------------------------------------------------
    def set_home_expanded(self, expanded: bool):
        """Show/hide home pass input + forgot pass."""
        self.home_expanded = expanded

        if self.homeExtraFrame:
            self.homeExtraFrame.setVisible(expanded)

        if self.exitBtn:
            self.exitBtn.setVisible(expanded)

        if self.homeFrame:
            if expanded:
                self.homeFrame.setMinimumHeight(400)
                self.homeFrame.setMaximumHeight(9999)
            else:
                self.homeFrame.setMinimumHeight(400)
                self.homeFrame.setMaximumHeight(400)

        # gate stays constant
        if self.gateFrame:
            self.gateFrame.setMinimumHeight(400)
            self.gateFrame.setMaximumHeight(400)

    def expand_home_card(self):
        self.set_home_expanded(True)

    def collapse_home_card(self):
        self.set_home_expanded(False)

    # ------------------------------------------------------
    # HOME PASS LOGIC
    # ------------------------------------------------------
    def _on_enter_home(self):
        """Enter key in homePassInput â†’ validate â†’ dashboard."""
        if not self.homePassInput:
            return

        pass_text = self.homePassInput.text().strip()

        if pass_text == "":
            QtWidgets.QMessageBox.warning(self, "Missing", "Enter a home pass.")
            return

        if not self.home_ctrl.validate_home_pass(self.username, pass_text):
            QtWidgets.QMessageBox.warning(self, "Invalid", "Incorrect home pass.")
            return

        # SUCCESS â†’ Open dashboard
        try:
            from views.dashboard import AdminWindow
            self.dash = AdminWindow(self.username)
            self.dash.show()
            self.close()
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "Error", f"Failed to open dashboard:\n{e}")
            return

        self.homePassInput.clear()
        self.collapse_home_card()

    # ------------------------------------------------------
    # FORGOT PASS LOGIC
    # ------------------------------------------------------
    def _on_forgot_pass(self):
        # 1. get questions
        ok, data = self.forgot_ctrl.get_questions(self.username)
        if not ok:
            QtWidgets.QMessageBox.warning(self, "Error", data)
            return

        q1, q2 = data["q1"], data["q2"]

        # 2. ask answers
        a1, ok = QtWidgets.QInputDialog.getText(self, "Security Check", q1)
        if not ok:
            return
        a2, ok = QtWidgets.QInputDialog.getText(self, "Security Check", q2)
        if not ok:
            return

        # 3. verify
        valid, _ = self.forgot_ctrl.verify_answers(self.username, a1, a2)
        if not valid:
            QtWidgets.QMessageBox.warning(self, "Error", "Incorrect answers.")
            return

        # 4. ask new homepass
        new_hp, ok = QtWidgets.QInputDialog.getText(self, "New Home Pass", "Enter new 5-digit home pass:")
        if not ok:
            return

        new_hp = new_hp.strip()

        # VALIDATION RULES (merged with profile)
        if not new_hp.isdigit() or len(new_hp) != 5:
            QtWidgets.QMessageBox.warning(self, "Error", "Home pass must be exactly 5 digits.")
            return

        # 5. disallow same as current homepass
        # (validate_home_pass is true if same)
        if self.home_ctrl.validate_home_pass(self.username, new_hp):
            QtWidgets.QMessageBox.warning(self, "Error", "New home pass cannot match the current one.")
            return

        # 6. update using SECURITY METHOD
        ok, msg = self.home_ctrl.change_homepass_with_security(self.username, new_hp)

        if not ok:
            QtWidgets.QMessageBox.warning(self, "Error", msg)
            return

        QtWidgets.QMessageBox.information(self, "Success", "Home pass updated successfully.")

    # ------------------------------------------------------
    # GATE MODE LOGIC
    # ------------------------------------------------------
    def _on_gate(self):
        """Same logic as old choose_mode: open scan window."""
        try:
            from views.scan import ScanWindow
            self.scan = ScanWindow(self.username)
            self.scan.show()
            self.close()
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "Error", f"Failed to open Gate view:\n{e}")

    def _on_back(self):
        reply = QtWidgets.QMessageBox.question(
            self,
            "Confirm Exit",
            "Are you sure you want to exit and return to the login page?",
            QtWidgets.QMessageBox.StandardButton.Yes | QtWidgets.QMessageBox.StandardButton.No
        )

        if reply == QtWidgets.QMessageBox.StandardButton.Yes:
            from views.login import LoginWindow
            self.login = LoginWindow()
            self.login.show()
            self.close()

    
# def main():
#     app = QtWidgets.QApplication(sys.argv)
#     win = ChooseModeWindow(username="demoUser")
#     win.show()
#     sys.exit(app.exec())


# if __name__ == "__main__":
#     main()





logs:
    
    
    
    # import sys
# from os import path
# from PyQt6 import QtWidgets, uic
# from PyQt6.QtGui import QPixmap
# from PyQt6.QtCore import Qt
# from PyQt6.QtWidgets import QWidget, QHBoxLayout, QPushButton, QTableWidgetItem

# BASE_DIR = path.dirname(path.abspath(__file__))
# PROJECT_ROOT = path.abspath(path.join(BASE_DIR, ".."))

# UI_FILE = path.join(PROJECT_ROOT, "ui", "logs.ui")
# BG_FILE = path.join(PROJECT_ROOT, "assets", "images", "bg1.png")


# class LogsWindow(QtWidgets.QMainWindow):
#     def __init__(self):
#         super().__init__()

#         # Load UI into QMainWindow
#         uic.loadUi(UI_FILE, self)


#         # --- Background image using QLabel (behind everything) ---
#         cw = self.findChild(QtWidgets.QWidget, "centralwidget")
#         self._bg_label = QtWidgets.QLabel(cw)
#         self._bg_pix = QPixmap(BG_FILE)
#         self._bg_label.setPixmap(self._bg_pix)
#         self._bg_label.setScaledContents(False)
#         self._bg_label.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
#         self._bg_label.lower()
#         self._bg_label.resize(cw.size())

#         # find table widget 
#         self.table = (
#             self.findChild(QtWidgets.QTableWidget, "logsTable")
#         )

#         if self.table is None:
#             print("Warning: table widget not found. Check objectName in logs.ui")
#         else:
#             if self.table.columnCount() < 4:
#                 self.table.setColumnCount(4)
#                 self.table.setHorizontalHeaderLabels(["DATE", "STUDENT", "DROP OFF", "PICK UP"])

#             # make table responsive and style it
#             self.setup_table()

#             # add sample rows so you can see how it looks
#             sample = [
#                 {"date": "10-30-2025", "student": "Name of student 1", "drop_off": "Name of Guardian", "pick_up": "Name of Guardian"},
#                 {"date": "10-30-2025", "student": "Name of student 1", "drop_off": "Name of Guardian", "pick_up": "Name of Guardian"},
#                 {"date": "10-30-2025", "student": "Name of student 1", "drop_off": "Name of Guardian", "pick_up": "Name of Guardian"},
#                 {"date": "10-30-2025", "student": "Name of student 1", "drop_off": "Name of Guardian", "pick_up": "Name of Guardian"},
#                 {"date": "10-30-2025", "student": "Name of student 1", "drop_off": "Name of Guardian", "pick_up": "Name of Guardian"},
#             ]
#             for s in sample:
#                 self.add_row(s["date"], s["student"], s["drop_off"], s["pick_up"])


#     # ----------------------------------------------------------------------------
#     # Function to add a row 
#     def add_row(self, date, student, drop_off, pick_up):
#         if self.table is None:
#             return

#         row = self.table.rowCount()
#         self.table.insertRow(row)

#         # DATE
#         date_item = QTableWidgetItem(date)
#         date_item.setFlags(date_item.flags() ^ Qt.ItemFlag.ItemIsEditable)
#         date_item.setTextAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
#         self.table.setItem(row, 0, date_item)

#         # STUDENT
#         student_item = QTableWidgetItem(student)
#         student_item.setFlags(student_item.flags() ^ Qt.ItemFlag.ItemIsEditable)
#         student_item.setTextAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
#         self.table.setItem(row, 1, student_item)

#         # DROP OFF
#         drop_item = QTableWidgetItem(drop_off)
#         drop_item.setFlags(drop_item.flags() ^ Qt.ItemFlag.ItemIsEditable)
#         drop_item.setTextAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
#         self.table.setItem(row, 2, drop_item)

#         # PICK UP
#         pick_item = QTableWidgetItem(pick_up)
#         pick_item.setFlags(pick_item.flags() ^ Qt.ItemFlag.ItemIsEditable)
#         pick_item.setTextAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
#         self.table.setItem(row, 3, pick_item)


#     # ----------------------------------------------------------------------------
#     # function to make the table responsive / stretch columns evenly
#     def setup_table(self):
#         if self.table is None:
#             return

#         try:
#             body_font = self.table.font()
#             body_font.setPointSize(13)
#             self.table.setFont(body_font)
#         except Exception:
#             pass

#         header = self.table.horizontalHeader()

#         # ---- Header font ----
#         try:
#             header_font = header.font()
#             header_font.setPointSize(13)   
#             header_font.setBold(True)      
#             header.setFont(header_font)
#             header.setDefaultAlignment(Qt.AlignLeft | Qt.AlignVCenter)
#         except Exception:
#             pass

#         # ---- 4 even columns ----
#         try:
#             header.setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Stretch)
#         except Exception:
#             pass

#         # Row + header heights
#         try:
#             self.table.verticalHeader().setDefaultSectionSize(54)
#         except Exception:
#             pass
#         try:
#             self.table.horizontalHeader().setFixedHeight(48)
#         except Exception:
#             pass

#         # Hide vertical row numbers
#         try:
#             self.table.verticalHeader().setVisible(False)
#         except Exception:
#             pass

#         # table style
#         self.table.setStyleSheet("""
#             QTableWidget {
#                 gridline-color: transparent;
#                 border: none;
#             }
#             QTableWidget::item {
#                 border: none;
#                 padding: 8px;
#             }
#             QHeaderView::section {
#                 border: none;
#                 background: transparent;
#                 padding-left: 12px;
#             }
#         """)



#     # ----------------------------------------------------------------------------
#     def resizeEvent(self, event):
#         super().resizeEvent(event)
#         # Resize background to fill area
#         try:
#             cw = self.findChild(QtWidgets.QWidget, "centralwidget")
#             scaled_bg = self._bg_pix.scaled(
#                 cw.size(),
#                 Qt.AspectRatioMode.KeepAspectRatioByExpanding,
#                 Qt.TransformationMode.SmoothTransformation
#             )
#             self._bg_label.setPixmap(scaled_bg)
#             self._bg_label.resize(cw.size())
#             self._bg_label.move(0, 0)
#         except Exception:
#             pass


# def main():
#     app = QtWidgets.QApplication(sys.argv)
#     win = LogsWindow()
#     win.show()
#     sys.exit(app.exec())


# if __name__ == "__main__":
#     main()






import sys
from os import path
from PyQt6 import QtWidgets, uic
from PyQt6.QtGui import QPixmap
from PyQt6.QtCore import Qt
from PyQt6.QtWidgets import QWidget, QHBoxLayout, QPushButton, QTableWidgetItem

BASE_DIR = path.dirname(path.abspath(__file__))
PROJECT_ROOT = path.abspath(path.join(BASE_DIR, ".."))

UI_FILE = path.join(PROJECT_ROOT, "ui", "logs.ui")
BG_FILE = path.join(PROJECT_ROOT, "assets", "images", "bg1.png")


from controller.LogsController import LogsController

class LogsWindow(QtWidgets.QMainWindow):
    def __init__(self, username):
        super().__init__()

        self.username = username

        
        self.resize(1200, 800)
        # Load UI
        uic.loadUi(UI_FILE, self)
        
        self.resize(1250, 800)

        # --- center window ---
        screen = QtWidgets.QApplication.primaryScreen().availableGeometry()
        win = self.frameGeometry()
        win.moveCenter(screen.center())
        self.move(win.topLeft())

        # --- background ---
        cw = self.findChild(QtWidgets.QWidget, "centralwidget")
        self._bg_label = QtWidgets.QLabel(cw)
        self._bg_pix = QPixmap(BG_FILE)
        self._bg_label.setPixmap(self._bg_pix)
        self._bg_label.setScaledContents(False)
        self._bg_label.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
        self._bg_label.lower()
        self._bg_label.resize(cw.size())

        # --- UI widgets ---
        self.table = self.findChild(QtWidgets.QTableWidget, "logsTable")
        self.searchInput = self.findChild(QtWidgets.QLineEdit, "searchInput")
        self.backBtn = self.findChild(QtWidgets.QPushButton, "backToDashboardBtn")

        # --- Keep your exact table setup (DO NOT CHANGE) ---
        self.setup_table()

        # Controller
        self.logs_controller = LogsController()

        # Search
        self.searchInput.textChanged.connect(self.load_logs)

        # Back
        # self.backBtn.clicked.connect(self.go_back)
        btn = self.findChild(QtWidgets.QPushButton, "backToDashboardBtn")
        if btn:
            btn.clicked.connect(self.go_to_dashboard)

        # Load data
        self.load_logs()

    # ------------------------------------------------------
    # def load_logs(self):
    #     """ Load logs from DB and display them without altering UI style """
    #     if self.table is None:
    #         return

    #     term = self.searchInput.text().strip()
    #     records = self.logs_controller.search_logs(self.username, term)

    #     # Clear table before inserting new rows
    #     self.table.setRowCount(0)

    #     for r in records:
    #         self.add_row(
    #             r["date_display"],
    #             r["studentname"],
    #             r["dropoff_by"] or "",
    #             r["pickup_by"] or ""
    #         )
    
    def load_logs(self):
        if self.table is None:
            return

        term = self.searchInput.text().strip()
        records = self.logs_controller.search_logs(self.username, term)

        self.table.setRowCount(0)

        for r in records:
            self.add_row(
                r["date_display"],
                r["studentname"],
                r["dropoff_by"],
                r["pickup_by"],
                r["dropoff_time"],
                r["pickup_time"]
            )


    # ------------------------------------------------------
    # KEEPING YOUR EXACT add_row STYLE â€” UNTOUCHED
    # def add_row(self, date, student, drop_off, pick_up):
    #     if self.table is None:
    #         return

    #     row = self.table.rowCount()
    #     self.table.insertRow(row)

    #     # DATE
    #     date_item = QTableWidgetItem(date)
    #     date_item.setFlags(date_item.flags() ^ Qt.ItemFlag.ItemIsEditable)
    #     date_item.setTextAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
    #     self.table.setItem(row, 0, date_item)

    #     # STUDENT
    #     student_item = QTableWidgetItem(student)
    #     student_item.setFlags(student_item.flags() ^ Qt.ItemFlag.ItemIsEditable)
    #     student_item.setTextAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
    #     self.table.setItem(row, 1, student_item)

    #     # DROP OFF
    #     drop_item = QTableWidgetItem(drop_off)
    #     drop_item.setFlags(drop_item.flags() ^ Qt.ItemFlag.ItemIsEditable)
    #     drop_item.setTextAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
    #     self.table.setItem(row, 2, drop_item)

    #     # PICK UP
    #     pick_item = QTableWidgetItem(pick_up)
    #     pick_item.setFlags(pick_item.flags() ^ Qt.ItemFlag.ItemIsEditable)
    #     pick_item.setTextAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
    #     self.table.setItem(row, 3, pick_item)



    def add_row(self, date, student, drop_by, pick_by, drop_time, pick_time):
        row = self.table.rowCount()
        self.table.insertRow(row)

        # DATE
        item_date = QTableWidgetItem(date)
        item_date.setFlags(item_date.flags() ^ Qt.ItemFlag.ItemIsEditable)
        self.table.setItem(row, 0, item_date)

        # STUDENT NAME
        item_student = QTableWidgetItem(student)
        item_student.setFlags(item_student.flags() ^ Qt.ItemFlag.ItemIsEditable)
        self.table.setItem(row, 1, item_student)

        # FORMAT DROP-OFF
        if drop_by:
            drop_txt = f"{drop_by}\n{drop_time.strftime('%I:%M %p') if drop_time else ''}"
        else:
            drop_txt = "â€”"

        drop_item = QTableWidgetItem(drop_txt)
        drop_item.setFlags(drop_item.flags() ^ Qt.ItemFlag.ItemIsEditable)
        self.table.setItem(row, 2, drop_item)

        # FORMAT PICK-UP
        if pick_by:
            pick_txt = f"{pick_by}\n{pick_time.strftime('%I:%M %p') if pick_time else ''}"
        else:
            pick_txt = "â€”"

        pick_item = QTableWidgetItem(pick_txt)
        pick_item.setFlags(pick_item.flags() ^ Qt.ItemFlag.ItemIsEditable)
        self.table.setItem(row, 3, pick_item)

        # Adjust row height for multiline
        self.table.setRowHeight(row, 55)

    # ------------------------------------------------------
    # KEEPING YOUR EXACT STYLE â€” NO CHANGES
    def setup_table(self):
        if self.table is None:
            return
        try:
            body_font = self.table.font()
            body_font.setPointSize(15)
            self.table.setFont(body_font)
        except: pass

        header = self.table.horizontalHeader()
        try:
            header_font = header.font()
            header_font.setPointSize(13)
            header_font.setBold(True)
            header.setFont(header_font)
            header.setDefaultAlignment(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft)
        except: pass

        try:
            header.setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Stretch)
        except: pass

        try:
            self.table.verticalHeader().setDefaultSectionSize(54)
            self.table.horizontalHeader().setFixedHeight(48)
            self.table.verticalHeader().setVisible(False)
        except: pass

        self.table.setStyleSheet("""
            QTableWidget {
                gridline-color: transparent;
                border: none;
            }
            QTableWidget::item {
                border: none;
                padding: 8px;
            }
            QHeaderView::section {
                border: none;
                background: transparent;
                padding-left: 12px;
            }
        """)

    # ------------------------------------------------------
    def go_to_dashboard(self):
        from views.dashboard import AdminWindow  # safe import
        self.dashboard = AdminWindow(self.username)
        self.dashboard.show()
        self.close()

    # ------------------------------------------------------------------------
    # Background scaling
    # ------------------------------------------------------------------------
    def resizeEvent(self, event):
        super().resizeEvent(event)
        try:
            cw = self.findChild(QtWidgets.QWidget, "centralwidget")
            scaled_bg = self._bg_pix.scaled(
                cw.size(),
                Qt.AspectRatioMode.KeepAspectRatioByExpanding,
                Qt.TransformationMode.SmoothTransformation
            )
            self._bg_label.setPixmap(scaled_bg)
            self._bg_label.resize(cw.size())
        except:
            pass
        
        
        
        
login:
    
    
    
    # import sys
# from os import path
# from PyQt6 import QtWidgets, uic
# from controller.LoginController import LoginController


# BASE_DIR = path.dirname(path.abspath(__file__))
# PROJECT_ROOT = path.abspath(path.join(BASE_DIR, ".."))

# UI_FILE = path.join(PROJECT_ROOT, "ui", "login.ui")


# class LoginWindow(QtWidgets.QMainWindow):
#     def __init__(self):
#         super().__init__()
#         uic.loadUi(UI_FILE, self)

#         # Inputs
#         self.userInput = self.findChild(QtWidgets.QLineEdit, "userInput")
#         self.passInput = self.findChild(QtWidgets.QLineEdit, "passInput")

#         # Buttons
#         self.loginBtn = self.findChild(QtWidgets.QPushButton, "loginBtn")
#         self.createBtn = self.findChild(QtWidgets.QPushButton, "createBtn")
#         self.forgotBtn = self.findChild(QtWidgets.QPushButton, "forgotBtn")

#         self.controller = LoginController()

#         # Connect
#         self.loginBtn.clicked.connect(self.handle_login)
#         self.createBtn.clicked.connect(self.go_signup)
#         self.forgotBtn.clicked.connect(self.go_forgot)


#     def handle_login(self):
#         username = self.userInput.text().strip()
#         password = self.passInput.text().strip()

#         ok, data = self.controller.login(username, password)

#         if ok:
#             from views.choose_mode import ChooseModeWindow  # â† IMPORT INSIDE
#             self.close()
#             self.mode = ChooseModeWindow()
#             self.mode.show()

#     def go_signup(self):
#         from views.signup import SignupWindow  # â† IMPORT INSIDE
#         self.close()
#         self.signup = SignupWindow()
#         self.signup.show()


#     def go_forgot(self):
#         from views.forgot_password import ForgotPasswordWindow  # â† IMPORT INSIDE
#         self.close()
#         self.x = ForgotPasswordWindow()
#         self.x.show()



import sys
from os import path
from PyQt6 import QtWidgets, uic
from PyQt6.QtGui import QPixmap
from PyQt6.QtCore import Qt
from controller.LoginController import LoginController

BASE_DIR = path.dirname(path.abspath(__file__))
PROJECT_ROOT = path.abspath(path.join(BASE_DIR, ".."))

UI_FILE = path.join(PROJECT_ROOT, "ui", "login.ui")
LOGO_FILE = path.join(PROJECT_ROOT, "assets", "images", "appLogo.png")
BG_FILE = path.join(PROJECT_ROOT, "assets", "images", "bg1.png")

class LoginWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()

        # Load UI
        uic.loadUi(UI_FILE, self)
        
        self.resize(1250, 800)

        # --- center window ---
        screen = QtWidgets.QApplication.primaryScreen().availableGeometry()
        win = self.frameGeometry()
        win.moveCenter(screen.center())
        self.move(win.topLeft())

        # Background setup
        cw = self.findChild(QtWidgets.QWidget, "centralwidget")

        self._bg_label = QtWidgets.QLabel(cw)
        self._bg_pix = QPixmap(BG_FILE)
        self._bg_label.setPixmap(self._bg_pix)
        self._bg_label.setScaledContents(False)
        self._bg_label.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
        self._bg_label.lower()
        self._bg_label.resize(cw.size())

        # Frames transparency
        right = self.findChild(QtWidgets.QFrame, "rightFrame")
        if right:
            right.setStyleSheet("background: transparent; border: none;")
            right.setAutoFillBackground(False)

        left = self.findChild(QtWidgets.QFrame, "leftFrame")
        if left:
            left.setStyleSheet("background: transparent; border: none;")
            left.setAutoFillBackground(False)

        # Logo
        self.logo_label = self.findChild(QtWidgets.QLabel, "logoLabel")
        self._orig_logo_pix = QPixmap(LOGO_FILE)
        if self.logo_label and not self._orig_logo_pix.isNull():
            self.logo_label.setStyleSheet("background: transparent;")
            self.logo_label.setPixmap(self._orig_logo_pix)

        # Inputs & Buttons
        self.userInput = self.findChild(QtWidgets.QLineEdit, "userInput")
        self.passInput = self.findChild(QtWidgets.QLineEdit, "passInput")
        self.loginBtn = self.findChild(QtWidgets.QPushButton, "loginBtn")
        self.createBtn = self.findChild(QtWidgets.QPushButton, "createBtn")
        self.forgotBtn = self.findChild(QtWidgets.QPushButton, "forgotBtn")

        self.controller = LoginController()

        # Button Actions
        self.loginBtn.clicked.connect(self.handle_login)
        self.createBtn.clicked.connect(self.go_signup)
        self.forgotBtn.clicked.connect(self.go_forgot)

        # Logo scaling limits
        self.MAX_PROP = 0.40
        self.ABS_MAX_W = 800
        self.ABS_MIN_W = 120


    def resizeEvent(self, event):
        super().resizeEvent(event)

        cw = self.findChild(QtWidgets.QWidget, "centralwidget")
        scaled_bg = self._bg_pix.scaled(
            cw.size(),
            Qt.AspectRatioMode.KeepAspectRatioByExpanding,
            Qt.TransformationMode.SmoothTransformation
        )
        self._bg_label.setPixmap(scaled_bg)
        self._bg_label.resize(cw.size())

        # Scale logo
        if not self._orig_logo_pix.isNull() and self.logo_label:
            target_w = int(self.width() * self.MAX_PROP)
            target_w = max(self.ABS_MIN_W, min(target_w, self.ABS_MAX_W))

            scaled_logo = self._orig_logo_pix.scaled(
                target_w, target_w,
                Qt.AspectRatioMode.KeepAspectRatio,
                Qt.TransformationMode.SmoothTransformation
            )
            self.logo_label.setPixmap(scaled_logo)


    def handle_login(self):
        username = self.userInput.text().strip()
        password = self.passInput.text().strip()

        ok, data = self.controller.login(username, password)

        if ok:
            from views.mode import ChooseModeWindow
            self.close()
            self.mode = ChooseModeWindow(username=username)
            self.mode.show()
        else:
            QtWidgets.QMessageBox.warning(self, "Login Failed", data)


    def go_signup(self):
        from views.signup import SignupWindow
        self.close()
        self.signup = SignupWindow()
        self.signup.show()


    def go_forgot(self):
        from controller.ForgotPasswordController import ForgotPasswordController
        ctrl = ForgotPasswordController()

        # username popup
        username, ok = QtWidgets.QInputDialog.getText(self, "Forgot Password", "Enter username:")
        if not ok or username.strip() == "":
            return

        # get security questions
        success, data = ctrl.get_questions(username)
        if not success:
            QtWidgets.QMessageBox.warning(self, "Error", data)
            return

        q1, q2 = data["q1"], data["q2"]

        # answer popup 1
        a1, ok = QtWidgets.QInputDialog.getText(self, "Security Question 1", q1)
        if not ok:
            return

        # answer popup 2
        a2, ok = QtWidgets.QInputDialog.getText(self, "Security Question 2", q2)
        if not ok:
            return

        # verify answers
        valid, msg = ctrl.verify_answers(username, a1, a2)
        if not valid:
            QtWidgets.QMessageBox.warning(self, "Error", msg)
            return

        # new password popup
        new_pass, ok = QtWidgets.QInputDialog.getText(self, "Reset Password", "Enter new password:")
        if not ok or new_pass.strip() == "":
            return

        from utils.password_validator import validate_password
        ok_pass, pass_msg = validate_password(new_pass)
        if not ok_pass:
            QtWidgets.QMessageBox.warning(self, "Invalid Password", pass_msg)
            return

        # update password
        success, msg = ctrl.update_password(username, new_pass)
        if not success:
            QtWidgets.QMessageBox.warning(self, "Error", msg)
            return

        QtWidgets.QMessageBox.information(self, "Success", "Password reset successfully!")



dashboard:
    
    
    
    # import sys
# from os import path
# from PyQt6 import QtWidgets, uic
# from PyQt6.QtGui import QPixmap
# from PyQt6.QtCore import Qt, QPropertyAnimation, QEasingCurve

# BASE_DIR = path.dirname(path.abspath(__file__))
# PROJECT_ROOT = path.abspath(path.join(BASE_DIR, ".."))

# UI_FILE = path.join(PROJECT_ROOT, "ui", "dashboard.ui")
# BG_FILE = path.join(PROJECT_ROOT, "assets", "images", "bg1.png")


# class AdminWindow(QtWidgets.QMainWindow):
#     def __init__(self):
#         super().__init__()

#         # Load UI into QMainWindow
#         uic.loadUi(UI_FILE, self)

#         # --- Background image using QLabel (behind everything) ---
#         cw = self.findChild(QtWidgets.QWidget, "centralwidget")

#         self._bg_label = QtWidgets.QLabel(cw)
#         self._bg_pix = QPixmap(BG_FILE)
#         self._bg_label.setPixmap(self._bg_pix)
#         self._bg_label.setScaledContents(False)
#         self._bg_label.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
#         self._bg_label.lower()
#         self._bg_label.resize(cw.size())

#         # --- Sidebar toggle setup ---

#         self.menu_widget = self.findChild(QtWidgets.QWidget, "menuSubContainer")
#         self.main_widget = self.findChild(QtWidgets.QWidget, "mainContainer")

#         self.left_frame = self.findChild(QtWidgets.QFrame, "leftFrame")

#         # DON'T trust .width() at init â€” layouts might not be applied yet.
#         self._menu_expanded_width = 500  # preferred fallback width

#         # prepare animation (if the menu exists)
#         if self.menu_widget:
#             self._menu_animation = QPropertyAnimation(self.menu_widget, b"maximumWidth")
#             self._menu_animation.setDuration(250)
#             self._menu_animation.setEasingCurve(QEasingCurve.Type.InOutCubic)
#             self.menu_widget.setMaximumWidth(self._menu_expanded_width)
#         else:
#             self._menu_animation = None

#         # Connect toggle buttons (picBtn to collapse, picBtn_2 to expand)
#         pic_btn = self.findChild(QtWidgets.QPushButton, "picBtn") or self.findChild(QtWidgets.QLabel, "picBtn")
#         pic_btn_2 = self.findChild(QtWidgets.QPushButton, "picBtn_2") or self.findChild(QtWidgets.QLabel, "picBtn_2")

#         if pic_btn is not None:
#             try:
#                 pic_btn.clicked.connect(self.collapse_menu)
#             except Exception:
#                 pic_btn.mousePressEvent = lambda ev: self.collapse_menu()
#         if pic_btn_2 is not None:
#             try:
#                 pic_btn_2.clicked.connect(self.expand_menu)
#             except Exception:
#                 pic_btn_2.mousePressEvent = lambda ev: self.expand_menu()

#         # -------- START HIDDEN: collapse the sidebar initially --------
#         # Ensure left_frame (the small left bar with picBtn_2/welcomeLabel) is visible when collapsed
#         if self.left_frame:
#             self.left_frame.setVisible(True)

#         # Collapse the menu visually at startup by forcing maximumWidth to 0.
#         # Note: showEvent will still compute the real expanded width later.
#         if self.menu_widget:
#             self.menu_widget.setMaximumWidth(0)
#             # also resize to zero width to avoid a flicker in some systems
#             try:
#                 self.menu_widget.resize(0, self.menu_widget.height())
#             except Exception:
#                 pass

#     def showEvent(self, event):
#         """
#         After window shown and layouts applied, record the real expanded width.
#         """
#         super().showEvent(event)
#         if self.menu_widget:
#             real_w = self.menu_widget.width()
#             hint_w = self.menu_widget.sizeHint().width() or self._menu_expanded_width
#             self._menu_expanded_width = real_w if real_w > 50 else (hint_w if hint_w > 50 else self._menu_expanded_width)
#             # don't automatically expand â€” just ensure the stored expanded width is correct
#             self.menu_widget.setMaximumWidth(0)  # keep collapsed at startup

#     def resizeEvent(self, event):
#         super().resizeEvent(event)
#         # Resize background to fill area
#         try:
#             cw = self.findChild(QtWidgets.QWidget, "centralwidget")
#             scaled_bg = self._bg_pix.scaled(
#                 cw.size(),
#                 Qt.AspectRatioMode.KeepAspectRatioByExpanding,
#                 Qt.TransformationMode.SmoothTransformation
#             )
#             self._bg_label.setPixmap(scaled_bg)
#             self._bg_label.resize(cw.size())
#             self._bg_label.move(0, 0)
#         except Exception:
#             pass

#     def _connect_finished_handler(self, handler):
#         """Helper: disconnect existing finished handlers then connect the new one."""
#         if not self._menu_animation:
#             return
#         try:
#             # attempt to disconnect all existing slots from finished
#             self._menu_animation.finished.disconnect()
#         except Exception:
#             # ignore if there were none
#             pass
#         try:
#             self._menu_animation.finished.connect(handler)
#         except Exception:
#             pass

#     def collapse_menu(self):
#         """
#         Animate sidebar to zero width (hide).
#         Show left_frame immediately (so it appears while sidebar is collapsed).
#         """
#         # If left_frame exists, show it immediately
#         if self.left_frame:
#             self.left_frame.setVisible(True)
#             # ensure UI updates immediately
#             self.left_frame.repaint()

#         if not self.menu_widget or not self._menu_animation:
#             return

#         current = self.menu_widget.width()

#         # finished handler: when collapse finishes, ensure maximumWidth stays at 0
#         def _on_collapse_finished():
#             try:
#                 # keep it collapsed
#                 self.menu_widget.setMaximumWidth(0)
#             except Exception:
#                 pass
#             try:
#                 self._menu_animation.finished.disconnect(_on_collapse_finished)
#             except Exception:
#                 pass

#         # connect handler and animate
#         self._connect_finished_handler(_on_collapse_finished)
#         self._menu_animation.stop()
#         self._menu_animation.setStartValue(current)
#         self._menu_animation.setEndValue(0)
#         self._menu_animation.start()

#     def expand_menu(self):
#         """
#         Animate sidebar back to original width (show).
#         Hide left_frame immediately so it won't be visible while sidebar is shown.
#         """
#         # Hide left_frame immediately (so it disappears before the expand)
#         if self.left_frame:
#             self.left_frame.setVisible(False)
#             # ensure UI updates immediately
#             self.left_frame.repaint()

#         if not self.menu_widget or not self._menu_animation:
#             return

#         current = self.menu_widget.width()
#         # recompute fallback if needed
#         if not self._menu_expanded_width or self._menu_expanded_width <= 50:
#             hint_w = self.menu_widget.sizeHint().width() or 500
#             self._menu_expanded_width = hint_w if hint_w > 50 else max(200, self._menu_expanded_width)

#         target = self._menu_expanded_width

#         # finished handler: after expand, set maximumWidth to target (stable)
#         def _on_expand_finished():
#             try:
#                 self.menu_widget.setMaximumWidth(target)
#             except Exception:
#                 pass
#             try:
#                 self._menu_animation.finished.disconnect(_on_expand_finished)
#             except Exception:
#                 pass

#         # connect handler and animate
#         self._connect_finished_handler(_on_expand_finished)
#         self._menu_animation.stop()
#         self._menu_animation.setStartValue(current)
#         self._menu_animation.setEndValue(target)
#         self._menu_animation.start()


# def main():
#     app = QtWidgets.QApplication(sys.argv)
#     win = AdminWindow()
#     win.show()
#     sys.exit(app.exec())


# if __name__ == "__main__":
#     main()





import sys
from os import path
from PyQt6 import QtWidgets, uic
from PyQt6.QtGui import QPixmap
from PyQt6.QtCore import Qt, QPropertyAnimation, QEasingCurve
from views.change_username import ChangeUsernameDialog
from views.change_password import ChangePasswordDialog
from views.change_homepass import ChangeHomepassDialog
from views.about import AboutDialog
from views.ask_help import AskHelpDialog

BASE_DIR = path.dirname(path.abspath(__file__))
PROJECT_ROOT = path.abspath(path.join(BASE_DIR, ".."))

UI_FILE = path.join(PROJECT_ROOT, "ui", "dashboard.ui")
BG_FILE = path.join(PROJECT_ROOT, "assets", "images", "bg1.png")



class AdminWindow(QtWidgets.QMainWindow):
    def __init__(self, username):
        super().__init__()
        self.username = username   # store username

        uic.loadUi(UI_FILE, self)
        
        self.resize(1250, 800)

        # --- center window ---
        screen = QtWidgets.QApplication.primaryScreen().availableGeometry()
        win = self.frameGeometry()
        win.moveCenter(screen.center())
        self.move(win.topLeft())

        # Background setup
        cw = self.findChild(QtWidgets.QWidget, "centralwidget")
        self._bg_label = QtWidgets.QLabel(cw)
        self._bg_pix = QPixmap(BG_FILE)
        self._bg_label.setPixmap(self._bg_pix)
        self._bg_label.setScaledContents(False)
        self._bg_label.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
        self._bg_label.lower()
        self._bg_label.resize(cw.size())

        # Sidebar
        self.menu_widget = self.findChild(QtWidgets.QWidget, "menuSubContainer")
        self.main_widget = self.findChild(QtWidgets.QWidget, "mainContainer")
        self.left_frame = self.findChild(QtWidgets.QFrame, "leftFrame")
        self._menu_expanded_width = 500

        if self.menu_widget:
            self._menu_animation = QPropertyAnimation(self.menu_widget, b"maximumWidth")
            self._menu_animation.setDuration(250)
            self._menu_animation.setEasingCurve(QEasingCurve.Type.InOutCubic)
            self.menu_widget.setMaximumWidth(self._menu_expanded_width)
        else:
            self._menu_animation = None

        pic_btn = self.findChild(QtWidgets.QPushButton, "picBtn") or self.findChild(QtWidgets.QLabel, "picBtn")
        pic_btn_2 = self.findChild(QtWidgets.QPushButton, "picBtn_2") or self.findChild(QtWidgets.QLabel, "picBtn_2")

        if pic_btn:
            try:
                pic_btn.clicked.connect(self.collapse_menu)
            except:
                pic_btn.mousePressEvent = lambda ev: self.collapse_menu()

        if pic_btn_2:
            try:
                pic_btn_2.clicked.connect(self.expand_menu)
            except:
                pic_btn_2.mousePressEvent = lambda ev: self.expand_menu()

        # collapse initially
        if self.left_frame:
            self.left_frame.setVisible(True)

        if self.menu_widget:
            self.menu_widget.setMaximumWidth(0)
            try:
                self.menu_widget.resize(0, self.menu_widget.height())
            except:
                pass

        # --------------------------------
        # DISPLAY USERNAME
        # --------------------------------
        self.adminLabel = self.findChild(QtWidgets.QLabel, "adminLabel")
        if self.adminLabel:
            self.adminLabel.setText(self.username)

        # --------------------------------
        # CHANGE USERNAME BUTTON
        # --------------------------------
        self.userBtn = self.findChild(QtWidgets.QPushButton, "userBtn")
        if self.userBtn:
            self.userBtn.clicked.connect(self.open_change_username)
        
        # --------------------------------
        # CHANGE PASSWORD BUTTON
        # --------------------------------
        self.passBtn = self.findChild(QtWidgets.QPushButton, "passBtn")
        if self.passBtn:
            self.passBtn.clicked.connect(self.open_change_password)
        
        # --------------------------------
        # CHANGE HOME PASSWORD BUTTON
        # --------------------------------
        self.homePassBtn = self.findChild(QtWidgets.QPushButton, "homePassBtn")
        if self.homePassBtn:
            self.homePassBtn.clicked.connect(self.open_change_hpassword)
            
        # --------------------------------
        # ABOUT BUTTON
        # --------------------------------
        self.aboutBtn = self.findChild(QtWidgets.QPushButton, "aboutBtn")
        if self.aboutBtn:
            self.aboutBtn.clicked.connect(self.open_about)
            
        # --------------------------------
        # ASK HELP BUTTON
        # --------------------------------
        self.askBtn = self.findChild(QtWidgets.QPushButton, "askBtn")
        if self.askBtn:
            self.askBtn.clicked.connect(self.open_help)
        
        # --------------------------------
        # LOGOUT BUTTON
        # --------------------------------
        self.logOutBtn = self.findChild(QtWidgets.QPushButton, "logOutBtn")
        if self.logOutBtn:
            self.logOutBtn.clicked.connect(self.logout)

        # --------------------------------
        # ROUTE TO STUDENT PAGE
        # --------------------------------
        self.StudentBtn = self.findChild(QtWidgets.QPushButton, "StudentBtn")
        if self.StudentBtn:
            self.StudentBtn.clicked.connect(self.go_student_page)

        # --------------------------------
        # ROUTE TO ATTENDANCE PAGE
        # --------------------------------
        self.attendanceBtn = self.findChild(QtWidgets.QPushButton, "attendanceBtn")
        if self.attendanceBtn:
            self.attendanceBtn.clicked.connect(self.go_attendance_page)
        
        # --------------------------------
        # ROUTE TO LOGS PAGE
        # --------------------------------
        self.guardianBtn = self.findChild(QtWidgets.QPushButton, "guardianBtn")
        if self.guardianBtn:
            self.guardianBtn.clicked.connect(self.go_logs_page)
        
        
    # ---------------- Logout Function ----------------
    def logout(self):
        reply = QtWidgets.QMessageBox.question(
            self,
            "Logout",
            "Are you sure you want to log out?",
            QtWidgets.QMessageBox.StandardButton.Yes | QtWidgets.QMessageBox.StandardButton.No
        )

        if reply == QtWidgets.QMessageBox.StandardButton.Yes:
            from views.mode import ChooseModeWindow
            self.close()
            self.login = ChooseModeWindow(self.username)
            self.login.show()


    # ---------------- Route Student Page ----------------
    def go_student_page(self):
        from views.student import StudentWindow
        self.close()
        self.stud = StudentWindow(self.username)
        self.stud.show()
       
        
    
    # ---------------- COLLAPSE MENU ----------------
    def collapse_menu(self):
        if self.left_frame:
            self.left_frame.setVisible(True)

        if not self.menu_widget or not self._menu_animation:
            return

        current = self.menu_widget.width()

        self._menu_animation.stop()
        self._menu_animation.setStartValue(current)
        self._menu_animation.setEndValue(0)
        self._menu_animation.start()


    # ---------------- EXPAND MENU ----------------
    def expand_menu(self):
        if self.left_frame:
            self.left_frame.setVisible(False)

        if not self.menu_widget or not self._menu_animation:
            return

        current = self.menu_widget.width()
        target = self._menu_expanded_width

        self._menu_animation.stop()
        self._menu_animation.setStartValue(current)
        self._menu_animation.setEndValue(target)
        self._menu_animation.start()




    def resizeEvent(self, event):
        super().resizeEvent(event)

        cw = self.findChild(QtWidgets.QWidget, "centralwidget")

        if hasattr(self, "_bg_pix") and hasattr(self, "_bg_label"):
            scaled_bg = self._bg_pix.scaled(
                cw.size(),
                Qt.AspectRatioMode.KeepAspectRatioByExpanding,
                Qt.TransformationMode.SmoothTransformation
            )
            self._bg_label.setPixmap(scaled_bg)
            self._bg_label.resize(cw.size())




    # ---------------- Change Username Button ----------------
    def open_change_username(self):
        dialog = ChangeUsernameDialog(self.username)
        if dialog.exec():
            self.username = dialog.current_username
            if self.adminLabel:
                self.adminLabel.setText(self.username)
                
    # ---------------- Change Password Button ----------------
    def open_change_password(self):
        dialog = ChangePasswordDialog(self.username)
        if dialog.exec():
            return
        
    # ---------------- Change Home Password Button ----------------
    def open_change_hpassword(self):
        dialog = ChangeHomepassDialog(self.username)
        if dialog.exec():
            return
        
    # ---------------- About Button ----------------
    def open_about(self):
        dialog = AboutDialog()
        if dialog.exec():
            return
    
    # ---------------- Ask Help Button ----------------
    def open_help(self):
        dialog = AskHelpDialog()
        if dialog.exec():
            return
        
    # ---------------- Open Attendance ----------------
    def go_attendance_page(self):
        from views.attendance import AttendanceWindow
        self.close()
        self.stud = AttendanceWindow(self.username)
        self.stud.show()
    
    # ---------------- Open Logs ----------------
    def go_logs_page(self):
        from views.logs import LogsWindow
        self.close()
        self.stud = LogsWindow(self.username)
        self.stud.show()
        



choose_mode:




# # entrysafe/views/choose_mode.py 

# import sys # Needed for sys.exit() and sys.argv
# from os import path 
# from PyQt6 import QtWidgets, uic, QtGui, QtCore 

# BASE_DIR = path.dirname(path.abspath(__file__))         # .../entrysafe/views 
# PROJECT_ROOT = path.abspath(path.join(BASE_DIR, ".."))  # .../entrysafe 

# UI_FILE = path.join(PROJECT_ROOT, "ui", "choose_mode.ui")
# GATE_ICON = path.join(PROJECT_ROOT, "assets", "images", "gate.png")
# HOME_ICON = path.join(PROJECT_ROOT, "assets", "images", "home.png")

# class ChooseModeWindow(QtWidgets.QWidget):
#     """
#     Mode selector widget. Emits mode_selected(mode, payload) on selection.
#     mode: 'gate' or 'home'
#     payload: dict (e.g. {'home_pass': 'abcd'})
#     """
#     mode_selected = QtCore.pyqtSignal(str, dict)

#     def __init__(self):
#         super().__init__()
        
#         # --- UI Loading ---
#         if not path.exists(UI_FILE):
#              print(f"FATAL ERROR: UI file not found at {UI_FILE}")
#              # If the UI file is missing, we stop initialization here.
#              return
#         else:
#             uic.loadUi(UI_FILE, self)

#         # find widgets (names must match UI)
#         self.gateBtn = self.findChild(QtWidgets.QPushButton, "gateBtn")
#         self.homePassInput = self.findChild(QtWidgets.QLineEdit, "homePassInput")
#         self.gateIcon = self.findChild(QtWidgets.QLabel, "gateIcon")
#         self.homeIcon = self.findChild(QtWidgets.QLabel, "homeIcon")
#         self.homeCard = self.findChild(QtWidgets.QFrame, "homeCard")
#         self.homeExpandFrame = self.findChild(QtWidgets.QFrame, "homeExpandFrame")
#         self.closeHomeBtn = self.findChild(QtWidgets.QPushButton, "closeHomeBtn") 
#         self.forgotPassBtn = self.findChild(QtWidgets.QPushButton, "forgotPassBtn")


#         # --- Defensive Checks ---
#         if not all([self.gateBtn, self.homePassInput, self.homeExpandFrame, self.homeCard, self.closeHomeBtn]):
#             print("WARNING: choose_mode UI missing crucial widgets. Check objectNames in UI file.")
#             # We can't proceed if essential widgets for interaction/animation are missing
#             return
#         if not all([self.gateBtn, self.homePassInput, self.homeExpandFrame,
#             self.homeCard, self.closeHomeBtn, self.forgotPassBtn]):
#             return

#         # --- Icon Setup ---
#         # Define the desired icon size (Updated from 160 to 200 pixels)
#         ICON_SIZE = 200 

#         if path.exists(GATE_ICON) and self.gateIcon:
#             pix = QtGui.QPixmap(GATE_ICON)
#             if not pix.isNull():
#                 self.gateIcon.setPixmap(pix.scaled(ICON_SIZE, ICON_SIZE, QtCore.Qt.AspectRatioMode.KeepAspectRatio, QtCore.Qt.TransformationMode.SmoothTransformation))
#         if path.exists(HOME_ICON) and self.homeIcon:
#             pix = QtGui.QPixmap(HOME_ICON)
#             if not pix.isNull():
#                 self.homeIcon.setPixmap(pix.scaled(ICON_SIZE, ICON_SIZE, QtCore.Qt.AspectRatioMode.KeepAspectRatio, QtCore.Qt.TransformationMode.SmoothTransformation))

#         # --- Connections ---
#         self.gateBtn.clicked.connect(self._on_gate)
#         self.homePassInput.returnPressed.connect(self._on_enter_home)
#         self.forgotPassBtn.clicked.connect(self._on_forgot_pass)
#         self.closeHomeBtn.clicked.connect(self._collapse_home_area) 
#         self.homeCard.mousePressEvent = self._home_card_clicked

#         # --- Animation and State Setup ---
#         self._expanded_height = 180 
#         self._anim_duration = 220    
#         self._is_expanded = False

#         # ensure homeExpandFrame starts collapsed (maxHeight 0) and hide the close button AND forgot pass button
#         self.homeExpandFrame.setMaximumHeight(0)
#         self.closeHomeBtn.hide()
#         self.forgotPassBtn.hide()


#     # ----- click handlers -----
#     def _home_card_clicked(self, event):
#         if event.button() == QtCore.Qt.MouseButton.LeftButton:
#             if self._is_expanded:
#                 self._collapse_home_area()
#             else:
#                 self._expand_home_area()

#     def _on_forgot_pass(self):
#         QtWidgets.QMessageBox.information(
#         self,
#         "Forgot Home Pass",
#         "Please contact your system administrator to reset your home pass."
#     )


#     def _expand_home_area(self):
#         if not self.homeExpandFrame:
#             return
        
#         # Animate and show the close button AND forgot pass button
#         start = self.homeExpandFrame.maximumHeight()
#         end = self._expanded_height
#         self._animate_home_expand(start, end)
#         self._is_expanded = True
#         self.closeHomeBtn.show()
#         self.forgotPassBtn.show()

#     def _collapse_home_area(self):
#         if not self.homeExpandFrame:
#             return
        
#         # Animate and hide the close button AND forgot pass button
#         start = self.homeExpandFrame.maximumHeight()
#         end = 0
#         self._animate_home_expand(start, end)
#         self._is_expanded = False
#         self.closeHomeBtn.hide()
#         self.forgotPassBtn.hide()

#     def _animate_home_expand(self, start, end):
#         if not self.homeExpandFrame:
#             return
#         # stop existing animation if any
#         try:
#             if hasattr(self, "_expand_anim") and self._expand_anim and self._expand_anim.state() == QtCore.QAbstractAnimation.State.Running:
#                 self._expand_anim.stop()
#         except Exception:
#             pass
            
#         self._expand_anim = QtCore.QPropertyAnimation(self.homeExpandFrame, b"maximumHeight")
#         self._expand_anim.setDuration(self._anim_duration)
#         self._expand_anim.setStartValue(start)
#         self._expand_anim.setEndValue(end)
#         self._expand_anim.setEasingCurve(QtCore.QEasingCurve.Type.OutCubic)
#         self._expand_anim.start()

#     def _on_gate(self):
#         # user chose gate -> emit and let app handle
#         self.mode_selected.emit('gate', {})

#     def _on_enter_home(self):
#         from controller.HomePassController import HomePassController
#         self.home_ctrl = HomePassController()

#         pass_text = self.homePassInput.text().strip()

#         if not pass_text:
#             QtWidgets.QMessageBox.warning(self, "Missing", "Enter a home pass.")
#             return

#         if not self.home_ctrl.validate_home_pass(pass_text):
#             QtWidgets.QMessageBox.warning(self, "Invalid", "Incorrect home pass.")
#             return

#         self.mode_selected.emit("home", {"home_pass": pass_text})

        
#         # clear field after emitting
#         if self.homePassInput:
#             self.homePassInput.clear()
            
#         # collapse the area after submit
#         self._collapse_home_area()
#         self._is_expanded = False

# if __name__ == '__main__':                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
#     # 1. Create the QApplication instance
#     app = QtWidgets.QApplication(sys.argv)
    
#     # 2. Create an instance of your custom widget/window
#     main_window = ChooseModeWindow()
    
#     # 3. Show the window
#     main_window.show() 
    
#     # 4. Start the application's event loop
#     sys.exit(app.exec())


# entrysafe/views/choose_mode.py

import sys  # needed for standalone test
from os import path
from PyQt6 import QtWidgets, uic, QtGui, QtCore

from controller.HomePassController import HomePassController
from controller.ForgotPasswordController import ForgotPasswordController

BASE_DIR = path.dirname(path.abspath(__file__))         # .../entrysafe/views
PROJECT_ROOT = path.abspath(path.join(BASE_DIR, ".."))  # .../entrysafe

UI_FILE = path.join(PROJECT_ROOT, "ui", "choose_mode.ui")
GATE_ICON = path.join(PROJECT_ROOT, "assets", "images", "gate.png")
HOME_ICON = path.join(PROJECT_ROOT, "assets", "images", "home.png")


class ChooseModeWindow(QtWidgets.QWidget):
    """
    Mode selector window: Gate mode or Home mode.
    """
    mode_selected = QtCore.pyqtSignal(str, dict)  # kept from old code (not strictly needed now)

    def __init__(self, username):
        super().__init__()
        self.username = username

        # --- UI Loading ---
        if not path.exists(UI_FILE):
            print(f"FATAL ERROR: UI file not found at {UI_FILE}")
            return

        uic.loadUi(UI_FILE, self)

        # controllers
        self.home_ctrl = HomePassController()
        self.forgot_ctrl = ForgotPasswordController()

        # --- Find widgets (names must match UI) ---
        self.gateBtn = self.findChild(QtWidgets.QPushButton, "gateBtn")
        self.homePassInput = self.findChild(QtWidgets.QLineEdit, "homePassInput")
        self.gateIcon = self.findChild(QtWidgets.QLabel, "gateIcon")
        self.homeIcon = self.findChild(QtWidgets.QLabel, "homeIcon")
        self.homeCard = self.findChild(QtWidgets.QFrame, "homeCard")
        self.homeExpandFrame = self.findChild(QtWidgets.QFrame, "homeExpandFrame")
        self.closeHomeBtn = self.findChild(QtWidgets.QPushButton, "closeHomeBtn")
        self.forgotPassBtn = self.findChild(QtWidgets.QPushButton, "forgotPassBtn")

        # Defensive check (same as your old code)
        if not all([self.gateBtn, self.homePassInput, self.homeExpandFrame,
                    self.homeCard, self.closeHomeBtn, self.forgotPassBtn]):
            print("WARNING: choose_mode UI missing crucial widgets. Check objectNames in UI file.")
            return

        # --- Icon Setup (same visuals, PyQt6 enums fixed) ---
        ICON_SIZE = 200

        if path.exists(GATE_ICON) and self.gateIcon:
            pix = QtGui.QPixmap(GATE_ICON)
            if not pix.isNull():
                self.gateIcon.setPixmap(
                    pix.scaled(
                        ICON_SIZE,
                        ICON_SIZE,
                        QtCore.Qt.AspectRatioMode.KeepAspectRatio,
                        QtCore.Qt.TransformationMode.SmoothTransformation
                    )
                )

        if path.exists(HOME_ICON) and self.homeIcon:
            pix = QtGui.QPixmap(HOME_ICON)
            if not pix.isNull():
                self.homeIcon.setPixmap(
                    pix.scaled(
                        ICON_SIZE,
                        ICON_SIZE,
                        QtCore.Qt.AspectRatioMode.KeepAspectRatio,
                        QtCore.Qt.TransformationMode.SmoothTransformation
                    )
                )

        # --- Connections (kept your behavior, changed targets) ---
        self.gateBtn.clicked.connect(self._on_gate)
        self.homePassInput.returnPressed.connect(self._on_enter_home)  # ENTER still works
        self.forgotPassBtn.clicked.connect(self._on_forgot_pass)
        self.closeHomeBtn.clicked.connect(self._collapse_home_area)

        # clicking the homeCard expands/collapses input
        self.homeCard.mousePressEvent = self._home_card_clicked

        # --- Animation and State Setup (same as old) ---
        self._expanded_height = 180
        self._anim_duration = 220
        self._is_expanded = False

        # start collapsed, hide buttons initially (same as old)
        self.homeExpandFrame.setMaximumHeight(0)
        self.closeHomeBtn.hide()
        self.forgotPassBtn.hide()

    # ----- click handlers -----
    def _home_card_clicked(self, event):
        # PyQt6: MouseButton.LeftButton
        if event.button() == QtCore.Qt.MouseButton.LeftButton:
            if self._is_expanded:
                self._collapse_home_area()
            else:
                self._expand_home_area()

    def _on_forgot_pass(self):
        """
        Forgot home pass:
        - ask security questions using ForgotPasswordController
        - if OK, ask for new home pass and update via HomePassController
        """
        ok, data = self.forgot_ctrl.get_questions(self.username)
        if not ok:
            QtWidgets.QMessageBox.warning(self, "Error", data)
            return

        q1, q2 = data["q1"], data["q2"]

        a1, ok = QtWidgets.QInputDialog.getText(self, "Security Check", q1)
        if not ok:
            return
        a2, ok = QtWidgets.QInputDialog.getText(self, "Security Check", q2)
        if not ok:
            return

        valid, msg = self.forgot_ctrl.verify_answers(self.username, a1, a2)
        if not valid:
            QtWidgets.QMessageBox.warning(self, "Error", "Incorrect answers.")
            return

        new_homepass, ok = QtWidgets.QInputDialog.getText(
            self, "New Home Pass", "Enter new home pass:"
        )
        if not ok or new_homepass.strip() == "":
            return

        if not self.home_ctrl.update_home_pass(self.username, new_homepass):
            QtWidgets.QMessageBox.warning(self, "Error", "Failed to update home pass.")
            return

        QtWidgets.QMessageBox.information(self, "Success", "Home pass updated successfully.")

    def _expand_home_area(self):
        if not self.homeExpandFrame:
            return

        start = self.homeExpandFrame.maximumHeight()
        end = self._expanded_height
        self._animate_home_expand(start, end)
        self._is_expanded = True
        self.closeHomeBtn.show()
        self.forgotPassBtn.show()

    def _collapse_home_area(self):
        if not self.homeExpandFrame:
            return

        start = self.homeExpandFrame.maximumHeight()
        end = 0
        self._animate_home_expand(start, end)
        self._is_expanded = False
        self.closeHomeBtn.hide()
        self.forgotPassBtn.hide()

    def _animate_home_expand(self, start, end):
        if not self.homeExpandFrame:
            return

        try:
            if hasattr(self, "_expand_anim") and self._expand_anim and \
               self._expand_anim.state() == QtCore.QAbstractAnimation.State.Running:
                self._expand_anim.stop()
        except Exception:
            pass

        self._expand_anim = QtCore.QPropertyAnimation(self.homeExpandFrame, b"maximumHeight")
        self._expand_anim.setDuration(self._anim_duration)
        self._expand_anim.setStartValue(start)
        self._expand_anim.setEndValue(end)
        # PyQt6: QEasingCurve.Type.OutCubic
        self._expand_anim.setEasingCurve(QtCore.QEasingCurve.Type.OutCubic)
        self._expand_anim.start()

    # ----- Gate mode -----
    def _on_gate(self):
        """
        Old behavior: emit signal.
        New behavior: directly open ScanWindow and close self.
        """
        try:
            from views.scan import ScanWindow
            self.scan = ScanWindow(self.username)
            self.scan.show()
            self.close()
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "Error", f"Failed to open Gate view:\n{e}")

    # ----- Home pass -----
    def _on_enter_home(self):
        """
        Called when user presses Enter in homePassInput (same as before, but with backend):
        - validate home pass in DB
        - if OK, open dashboard
        """
        if not self.homePassInput:
            return

        pass_text = self.homePassInput.text().strip()

        if not pass_text:
            QtWidgets.QMessageBox.warning(self, "Missing", "Enter a home pass.")
            return

        # Use username-based validation
        if not self.home_ctrl.validate_home_pass(self.username, pass_text):
            QtWidgets.QMessageBox.warning(self, "Invalid", "Incorrect home pass.")
            return

        # SUCCESS â†’ open dashboard
        try:
            from views.dashboard import AdminWindow
            self.dash = AdminWindow(self.username)
            self.dash.show()
            self.close()
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "Error", f"Failed to open dashboard:\n{e}")
            return

        # clear field after success
        self.homePassInput.clear()
        self._collapse_home_area()


if __name__ == '__main__':
    app = QtWidgets.QApplication(sys.argv)
    win = ChooseModeWindow(username="demoUser")
    win.show()
    sys.exit(app.exec())





attendance:





# import sys
# from os import path
# from PyQt6 import QtWidgets, uic
# from PyQt6.QtGui import QPixmap
# from PyQt6.QtCore import Qt
# from PyQt6.QtWidgets import QWidget, QHBoxLayout, QPushButton, QTableWidgetItem

# BASE_DIR = path.dirname(path.abspath(__file__))
# PROJECT_ROOT = path.abspath(path.join(BASE_DIR, ".."))

# UI_FILE = path.join(PROJECT_ROOT, "ui", "attendance.ui")
# BG_FILE = path.join(PROJECT_ROOT, "assets", "images", "bg1.png")


# class AttendanceWindow(QtWidgets.QMainWindow):
#     def __init__(self):
#         super().__init__()

#         # Load UI into QMainWindow
#         uic.loadUi(UI_FILE, self)


#         # --- Background image using QLabel (behind everything) ---
#         cw = self.findChild(QtWidgets.QWidget, "centralwidget")
#         self._bg_label = QtWidgets.QLabel(cw)
#         self._bg_pix = QPixmap(BG_FILE)
#         self._bg_label.setPixmap(self._bg_pix)
#         self._bg_label.setScaledContents(False)
#         self._bg_label.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
#         self._bg_label.lower()
#         self._bg_label.resize(cw.size())

#         # find table widget 
#         self.table = (
#             self.findChild(QtWidgets.QTableWidget, "attendanceTable")
#         )

#         if self.table is None:
#             print("Warning: table widget not found. Check objectName in attendance.ui")
#         else:
#             if self.table.columnCount() < 3:
#                 self.table.setColumnCount(3)
#                 self.table.setHorizontalHeaderLabels(["DATE", "STUDENT ID", "STUDENT NAME"])

#             # make table responsive and style it
#             self.setup_table()

#             # add sample rows so you can see how it looks
            
#         from controller.AttendanceController import AttendanceController
#         self.attendance_controller = AttendanceController()

#         if self.searchStudent:
#             self.searchStudent.textChanged.connect(self.load_attendance)

#         def load_attendance(self):
#             if self.table is None:
#                 return

#             term = self.searchStudent.text().strip() if self.searchStudent else ""

#             records = self.attendance_controller.search_attendance(term)

#             self.table.setRowCount(0)

#             for r in records:
#                 row = self.table.rowCount()
#                 self.table.insertRow(row)

#                 # Date
#                 date_item = QTableWidgetItem(str(r["date"]))
#                 date_item.setFlags(date_item.flags() ^ Qt.ItemFlag.ItemIsEditable)
#                 self.table.setItem(row, 0, date_item)

#                 # Student ID
#                 id_item = QTableWidgetItem(r["studid"])
#                 id_item.setFlags(id_item.flags() ^ Qt.ItemFlag.ItemIsEditable)
#                 self.table.setItem(row, 1, id_item)

#                 # Student Name
#                 name_item = QTableWidgetItem(r["studentname"])
#                 name_item.setFlags(name_item.flags() ^ Qt.ItemFlag.ItemIsEditable)
#                 self.table.setItem(row, 2, name_item)

#     # ----------------------------------------------------------------------------
#     # Function to add a row 
#     def add_row(self, date, student_id, student_name):
#         if self.table is None:
#             return

#         row = self.table.rowCount()
#         self.table.insertRow(row)

#         # DATE
#         date_item = QTableWidgetItem(date)
#         date_item.setFlags(date_item.flags() ^ Qt.ItemFlag.ItemIsEditable)
#         date_item.setTextAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
#         self.table.setItem(row, 0, date_item)

#         # STUDENT ID
#         student_item = QTableWidgetItem(student_id)
#         student_item.setFlags(student_item.flags() ^ Qt.ItemFlag.ItemIsEditable)
#         student_item.setTextAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
#         self.table.setItem(row, 1, student_item)

#         # STUDENT NAME
#         drop_item = QTableWidgetItem(student_name)
#         drop_item.setFlags(drop_item.flags() ^ Qt.ItemFlag.ItemIsEditable)
#         drop_item.setTextAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
#         self.table.setItem(row, 2, drop_item)



#     # ----------------------------------------------------------------------------
#     # function to make the table responsive / stretch columns evenly
#     def setup_table(self):
#         if self.table is None:
#             return

#         try:
#             body_font = self.table.font()
#             body_font.setPointSize(13)
#             self.table.setFont(body_font)
#         except Exception:
#             pass

#         header = self.table.horizontalHeader()

#         # ---- Header font ----
#         try:
#             header_font = header.font()
#             header_font.setPointSize(13)   
#             header_font.setBold(True)      
#             header.setFont(header_font)
#             header.setDefaultAlignment(Qt.AlignLeft | Qt.AlignVCenter)
#         except Exception:
#             pass

#         # ---- 3 even columns ----
#         try:
#             header.setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Stretch)
#         except Exception:
#             pass

#         # Row + header heights
#         try:
#             self.table.verticalHeader().setDefaultSectionSize(54)
#         except Exception:
#             pass
#         try:
#             self.table.horizontalHeader().setFixedHeight(48)
#         except Exception:
#             pass

#         # Hide vertical row numbers
#         try:
#             self.table.verticalHeader().setVisible(False)
#         except Exception:
#             pass

#         # table style
#         self.table.setStyleSheet("""
#             QTableWidget {
#                 gridline-color: transparent;
#                 border: none;
#             }
#             QTableWidget::item {
#                 border: none;
#                 padding: 8px;
#             }
#             QHeaderView::section {
#                 border: none;
#                 background: transparent;
#                 padding-left: 12px;
#             }
#         """)



#     # ----------------------------------------------------------------------------
#     def resizeEvent(self, event):
#         super().resizeEvent(event)
#         # Resize background to fill area
#         try:
#             cw = self.findChild(QtWidgets.QWidget, "centralwidget")
#             scaled_bg = self._bg_pix.scaled(
#                 cw.size(),
#                 Qt.AspectRatioMode.KeepAspectRatioByExpanding,
#                 Qt.TransformationMode.SmoothTransformation
#             )
#             self._bg_label.setPixmap(scaled_bg)
#             self._bg_label.resize(cw.size())
#             self._bg_label.move(0, 0)
#         except Exception:
#             pass


# def main():
#     app = QtWidgets.QApplication(sys.argv)
#     win = AttendanceWindow()
#     win.show()
#     sys.exit(app.exec())


# if __name__ == "__main__":
#     main()




import sys
from os import path
from PyQt6 import QtWidgets, uic
from PyQt6.QtGui import QPixmap
from PyQt6.QtCore import Qt
from PyQt6.QtWidgets import QWidget, QHBoxLayout, QPushButton, QTableWidgetItem

from controller.AttendanceController import AttendanceController

BASE_DIR = path.dirname(path.abspath(__file__))
PROJECT_ROOT = path.abspath(path.join(BASE_DIR, ".."))

UI_FILE = path.join(PROJECT_ROOT, "ui", "attendance.ui")
BG_FILE = path.join(PROJECT_ROOT, "assets", "images", "bg1.png")


class AttendanceWindow(QtWidgets.QMainWindow):
    def __init__(self, username):
        super().__init__()
        self.username = username


        uic.loadUi(UI_FILE, self)
        
        self.resize(1250, 800)

        # --- center window ---
        screen = QtWidgets.QApplication.primaryScreen().availableGeometry()
        win = self.frameGeometry()
        win.moveCenter(screen.center())
        self.move(win.topLeft())

        # Controller
        self.attendance_controller = AttendanceController()

        # Background setup
        cw = self.findChild(QtWidgets.QWidget, "centralwidget")
        self._bg_label = QtWidgets.QLabel(cw)
        self._bg_pix = QPixmap(BG_FILE)
        self._bg_label.setPixmap(self._bg_pix)
        self._bg_label.setScaledContents(False)
        self._bg_label.lower()
        self._bg_label.resize(cw.size())

        # Search bar
        self.searchStudent = self.findChild(QtWidgets.QLineEdit, "searchStudent")
        if self.searchStudent:
            self.searchStudent.textChanged.connect(self.load_attendance)

        # Table
        self.table = self.findChild(QtWidgets.QTableWidget, "attendanceTable")

        if self.table:
            self.table.setColumnCount(3)
            self.table.setHorizontalHeaderLabels(["DATE", "STUDENT ID", "STUDENT NAME"])
            self.setup_table()

        # Load data initially
        self.load_attendance()

    
        btn = self.findChild(QtWidgets.QPushButton, "backToDashboardBtn")
        if btn:
            btn.clicked.connect(self.go_to_dashboard)
    
    # ------------------------------------------------------------------------
    # Load attendance records from DB
    # ------------------------------------------------------------------------
    def load_attendance(self):
        if self.table is None:
            return

        term = self.searchStudent.text().strip() if self.searchStudent else ""
        records = self.attendance_controller.search_attendance(self.username, term)


        self.table.setRowCount(0)

        for r in records:
            row = self.table.rowCount()
            self.table.insertRow(row)

            # DATE (with time)
            item_date = QTableWidgetItem(str(r["date_display"]))
            item_date.setFlags(item_date.flags() ^ Qt.ItemFlag.ItemIsEditable)
            item_date.setTextAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
            self.table.setItem(row, 0, item_date)

            # STUDENT ID
            item_id = QTableWidgetItem(r["studid"])
            item_id.setFlags(item_id.flags() ^ Qt.ItemFlag.ItemIsEditable)
            item_id.setTextAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
            self.table.setItem(row, 1, item_id)

            # STUDENT NAME
            item_name = QTableWidgetItem(r["studentname"])
            item_name.setFlags(item_name.flags() ^ Qt.ItemFlag.ItemIsEditable)
            item_name.setTextAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
            self.table.setItem(row, 2, item_name)


    # ------------------------------------------------------------------------
    # Table design / responsive layout
    # ------------------------------------------------------------------------
    def setup_table(self):
        header = self.table.horizontalHeader()
        header.setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Stretch)

        body_font = self.table.font()
        body_font.setPointSize(15)
        self.table.setFont(body_font)

        header_font = header.font()
        header_font.setPointSize(13)
        header_font.setBold(True)
        header.setFont(header_font)
        header.setDefaultAlignment(
            Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter
        )


        self.table.verticalHeader().setDefaultSectionSize(54)
        self.table.horizontalHeader().setFixedHeight(48)
        self.table.verticalHeader().setVisible(False)

        self.table.setStyleSheet("""
            QTableWidget {
                border: none;
                gridline-color: transparent;
            }
            QTableWidget::item {
                border: none;
                padding: 8px;
            }
            QHeaderView::section {
                border: none;
                background: transparent;
                padding-left: 12px;
            }
        """)

    # ------------------------------------------------------------------------
    # Background scaling
    # ------------------------------------------------------------------------
    def resizeEvent(self, event):
        super().resizeEvent(event)
        try:
            cw = self.findChild(QtWidgets.QWidget, "centralwidget")
            scaled_bg = self._bg_pix.scaled(
                cw.size(),
                Qt.AspectRatioMode.KeepAspectRatioByExpanding,
                Qt.TransformationMode.SmoothTransformation
            )
            self._bg_label.setPixmap(scaled_bg)
            self._bg_label.resize(cw.size())
        except:
            pass
    
    
    def go_to_dashboard(self):
        from views.dashboard import AdminWindow  # safe import
        self.dashboard = AdminWindow(self.username)
        self.dashboard.show()
        self.close()


# # Standalone test
# def main():
#     app = QtWidgets.QApplication(sys.argv)
#     win = AttendanceWindow()
#     win.show()
#     sys.exit(app.exec())


# if __name__ == "__main__":
#     main()






forgotpasscontroller:



# from database.connection import Database

# class ForgotPasswordController:
#     def __init__(self):
#         self.db = Database()
#         self.conn = self.db.connect()

#     def get_questions(self):
#         try:
#             cur = self.conn.cursor()
#             cur.execute("SELECT * FROM get_security_questions()")
#             result = cur.fetchone()
#             return result  # (q1, q2)
#         except Exception:
#             return None

#     def verify_answers(self, a1, a2):
#         try:
#             cur = self.conn.cursor()
#             cur.execute("SELECT verify_security_answers(%s, %s)", (a1.lower(), a2.lower()))
#             result = cur.fetchone()
#             return bool(result[0])
#         except Exception:
#             return False

#     def update_password(self, new_pass):
#         try:
#             cur = self.conn.cursor()
#             cur.execute("CALL update_user_password(%s)", (new_pass,))
#             self.conn.commit()
#             return True
#         except Exception:
#             self.conn.rollback()
#             return False




from database.connection import Database
import psycopg2

class ForgotPasswordController:
    def __init__(self):
        self.db = Database()
        self.conn = self.db.connect()

    def get_questions(self, username):
        try:
            cur = self.conn.cursor()
            cur.execute("SELECT q1, q2 FROM get_security_questions(%s);", (username,))
            row = cur.fetchone()
            if not row:
                return False, "Username not found."
            return True, {"q1": row[0], "q2": row[1]}
        except Exception as e:
            return False, str(e)

    def verify_answers(self, username, a1, a2):
        try:
            cur = self.conn.cursor()
            cur.execute("""
                SELECT verify_security_answers(%s, %s, %s);
            """, (username, a1, a2))
            result = cur.fetchone()[0]
            return (True, "Correct answers.") if result else (False, "Incorrect answers.")
        except Exception as e:
            return False, str(e)

    def update_password(self, username, new_pass):
        try:
            cur = self.conn.cursor()

            # Check if new password matches current password
            cur.execute("SELECT is_same_password(%s, %s);", (username, new_pass))
            same = cur.fetchone()[0]

            if same:
                return False, "New password cannot be the same as the current password."

            # Continue if different
            cur.execute("""
                CALL update_user_password(%s, %s);
            """, (username, new_pass))
            self.conn.commit()

            return True, "Password updated successfully."

        except Exception as e:
            self.conn.rollback()
            return False, str(e)




guardian controller:



# import os
# import numpy as np
# import psycopg2
# from psycopg2.extras import RealDictCursor
# from database.connection import Database

# UPLOAD_DIR = "uploads/guardians"

# class GuardianController:
#     def __init__(self):
#         self.db = Database()
#         self.conn = self.db.connect()
#         self.cursor = self.conn.cursor(cursor_factory=RealDictCursor)

#         # ensure folder
#         if not os.path.exists(UPLOAD_DIR):
#             os.makedirs(UPLOAD_DIR)

#     # ===============================================
#     # Encode / Decode (BYTEA â€” correct format)
#     # ===============================================
#     def encode_face(self, embedding):
#         """
#         Convert numpy embedding â†’ BYTEA for PostgreSQL.
#         """
#         arr = np.array(embedding, dtype=np.float32)
#         return psycopg2.Binary(arr.tobytes())   # REAL BYTEA

#     def decode_face(self, bytea_data):
#         """
#         Convert BYTEA â†’ numpy array
#         """
#         if bytea_data is None:
#             return None
#         return np.frombuffer(bytea_data, dtype=np.float32)

#     # ===============================================
#     # INSERT Guardian
#     # ===============================================
#     def insert_guardian(self, studid, name, dob, image_path, encoding):
#         print("ðŸ”¥ INSERT GUARDIAN â€” Encoding type:", type(encoding))

#         self.cursor.execute("""
#             CALL add_guardian(%s, %s, %s, %s, %s::bytea);
#         """, (studid, name, dob, image_path, encoding))

#         self.conn.commit()
#         return True

#     # ===============================================
#     # UPDATE Guardian
#     # ===============================================
#     def update_guardian(self, guardianid, name, dob, image_path, encoding):
#         self.cursor.execute("""
#             CALL update_guardian(%s, %s, %s, %s, %s::bytea);
#         """, (guardianid, name, dob, image_path, encoding))

#         self.conn.commit()
#         return True

#     # ===============================================
#     # DELETE Guardian
#     # ===============================================
#     def delete_guardian(self, guardianid):
#         self.cursor.execute("CALL delete_guardian(%s);", (guardianid,))
#         self.conn.commit()
#         return True

#     # ===============================================
#     # GET Guardians for student
#     # ===============================================
#     def get_guardians_for_student(self, studentid):
#         self.cursor.execute("""
#             SELECT * FROM get_guardians_for_student(%s);
#         """, (studentid,))
#         return self.cursor.fetchall()

    
#     def call_dropoff(self, studid, guardian_name, is_manual):
#         self.cursor.execute("CALL mark_dropoff(%s, %s, %s)", 
#                             (studid, guardian_name, is_manual))
#         self.conn.commit()


#     def call_pickup(self, studid, guardian_name, is_manual):
#         self.cursor.execute("CALL mark_pickup(%s, %s, %s)", 
#                             (studid, guardian_name, is_manual))
#         self.conn.commit()

    
#     # def update_log_guardian(self, studid, guardian_name):
#     #     """
#     #     Updates ONLY the field that was previously 'UNVERIFIED GUARDIAN'.
#     #     Does NOT overwrite correct verified guardian names.
#     #     """
#     #     sql = """
#     #         UPDATE logs
#     #         SET 
#     #             dropoff_by = CASE 
#     #                 WHEN dropoff_by = 'UNVERIFIED GUARDIAN' 
#     #                 THEN %s 
#     #                 ELSE dropoff_by 
#     #             END,
#     #             pickup_by = CASE 
#     #                 WHEN pickup_by = 'UNVERIFIED GUARDIAN' 
#     #                 THEN %s 
#     #                 ELSE pickup_by 
#     #             END
#     #         WHERE studid = %s AND date = CURRENT_DATE;
#     #     """

#     #     self.cursor.execute(sql, (guardian_name, guardian_name, studid))
#     #     self.conn.commit()

#     def get_today_attendance(self, studid: str):
#         self.cursor.execute(
#             """
#             SELECT date, dropoff_time, pickup_time
#             FROM attendance
#             WHERE studid = %s AND date = CURRENT_DATE
#             LIMIT 1;
#             """,
#             (studid,)
#         )
#         row = self.cursor.fetchone()
#         return row  # may be None
    
#     def update_dropoff_guardian(self, studid, name):
#         sql = """
#             UPDATE logs
#             SET dropoff_by = %s
#             WHERE studid = %s AND date = CURRENT_DATE;
#         """
#         self.cursor.execute(sql, (name, studid))
#         self.conn.commit()


#     def update_pickup_guardian(self, studid, name):
#         sql = """
#             UPDATE logs
#             SET pickup_by = %s
#             WHERE studid = %s AND date = CURRENT_DATE;
#         """
#         self.cursor.execute(sql, (name, studid))
#         self.conn.commit()

#     def get_guardian_by_id(self, guardianid):
#         self.cursor.execute("""
#             SELECT guardianid, studid, guardianname, guardiandob,
#                 face_image_path, face_encoding
#             FROM guardians
#             WHERE guardianid = %s
#             LIMIT 1;
#         """, (guardianid,))
        
#         return self.cursor.fetchone()


import os
import numpy as np
import psycopg2
from psycopg2.extras import RealDictCursor
from database.connection import Database

UPLOAD_DIR = "uploads/guardians"


class GuardianController:
    def __init__(self):
        self.db = Database()
        self.conn = self.db.connect()
        self.cursor = self.conn.cursor(cursor_factory=RealDictCursor)

        if not os.path.exists(UPLOAD_DIR):
            os.makedirs(UPLOAD_DIR)

    # ===============================================
    # Encode / Decode face embedding
    # ===============================================
    def encode_face(self, embedding):
        arr = np.array(embedding, dtype=np.float32)
        return psycopg2.Binary(arr.tobytes())

    def decode_face(self, bytea_data):
        if bytea_data is None:
            return None
        return np.frombuffer(bytea_data, dtype=np.float32)

    # ===============================================
    # INSERT Guardian  (NOW: studentid INT, not studid code)
    # ===============================================
    def insert_guardian(self, studentid, name, dob, image_path, encoding):
        print("ðŸ”¥ INSERT GUARDIAN â€” Encoding type:", type(encoding))
        self.cursor.execute("""
            CALL add_guardian(%s, %s, %s, %s, %s::bytea);
        """, (studentid, name, dob, image_path, encoding))
        self.conn.commit()
        return True

    # ===============================================
    # UPDATE Guardian
    # ===============================================
    def update_guardian(self, guardianid, name, dob, image_path, encoding):
        self.cursor.execute("""
            CALL update_guardian(%s, %s, %s, %s, %s::bytea);
        """, (guardianid, name, dob, image_path, encoding))
        self.conn.commit()
        return True

    # ===============================================
    # DELETE Guardian
    # ===============================================
    def delete_guardian(self, guardianid):
        self.cursor.execute("CALL delete_guardian(%s);", (guardianid,))
        self.conn.commit()
        return True

    # ===============================================
    # GET Guardians for student (by studentid INT)
    # ===============================================
    def get_guardians_for_student(self, studentid):
        self.cursor.execute("""
            SELECT * FROM get_guardians_for_student(%s);
        """, (studentid,))
        return self.cursor.fetchall()

    # ===============================================
    # Attendance / Logs by STUDENTID
    # ===============================================
    def call_dropoff(self, studentid, guardian_name, is_manual):
        self.cursor.execute(
            "CALL mark_dropoff(%s, %s, %s)",
            (studentid, guardian_name, is_manual)
        )
        self.conn.commit()

    def call_pickup(self, studentid, guardian_name, is_manual):
        self.cursor.execute(
            "CALL mark_pickup(%s, %s, %s)",
            (studentid, guardian_name, is_manual)
        )
        self.conn.commit()

    def get_today_attendance(self, studentid: int):
        self.cursor.execute(
            """
            SELECT date, dropoff_time, pickup_time
            FROM attendance
            WHERE studentid = %s AND date = CURRENT_DATE
            LIMIT 1;
            """,
            (studentid,)
        )
        return self.cursor.fetchone()

    def update_dropoff_guardian(self, studentid, name):
        sql = """
            UPDATE logs
            SET dropoff_by = %s
            WHERE studentid = %s AND date = CURRENT_DATE;
        """
        self.cursor.execute(sql, (name, studentid))
        self.conn.commit()

    def update_pickup_guardian(self, studentid, name):
        sql = """
            UPDATE logs
            SET pickup_by = %s
            WHERE studentid = %s AND date = CURRENT_DATE;
        """
        self.cursor.execute(sql, (name, studentid))
        self.conn.commit()

    def get_guardian_by_id(self, guardianid):
        self.cursor.execute("""
            SELECT guardianid, studentid, guardianname, guardiandob,
                   face_image_path, face_encoding
            FROM guardians
            WHERE guardianid = %s
            LIMIT 1;
        """, (guardianid,))
        return self.cursor.fetchone()

    def manual_dropoff(self, studentid, guardian_name):
        # update attendance time
        self.cursor.execute("""
            UPDATE attendance
            SET dropoff_time = NOW()
            WHERE studentid = %s AND date = CURRENT_DATE;
        """, (studentid,))

        # update logs guardian name
        self.cursor.execute("""
            UPDATE logs
            SET dropoff_by = %s
            WHERE studentid = %s AND date = CURRENT_DATE;
        """, (guardian_name, studentid))

        self.conn.commit()

    
    def manual_pickup(self, studentid, guardian_name):
        # update attendance time
        self.cursor.execute("""
            UPDATE attendance
            SET pickup_time = NOW()
            WHERE studentid = %s AND date = CURRENT_DATE;
        """, (studentid,))

        # update logs guardian name
        self.cursor.execute("""
            UPDATE logs
            SET pickup_by = %s
            WHERE studentid = %s AND date = CURRENT_DATE;
        """, (guardian_name, studentid))

        self.conn.commit()






studentcontroller:




# from datetime import datetime
# from database.connection import Database
# from psycopg2.extras import RealDictCursor   # ADD THIS


# class StudentController:
#     def __init__(self):
#         self.db = Database()
#         self.conn = self.db.connect()
#         self.cursor = self.conn.cursor(cursor_factory=RealDictCursor)  # FIXED

#     # -------------------------------------------------
#     # Generate Student Code (S001, S002, ...)
#     # -------------------------------------------------
#     def generate_student_id(self, username):
#         self.cursor.execute("""
#             SELECT studID FROM students
#             WHERE username = %s
#             ORDER BY studID DESC LIMIT 1
#         """, (username,))

#         row = self.cursor.fetchone()

#         if row is None:
#             return "S001"

#         last_id = row["studID"]  # S005 âž 5 âž 6 âž S006
#         num = int(last_id[1:]) + 1
#         return f"S{num:03d}"

#     # -------------------------------------------------
#     # Load all students for this user
#     # -------------------------------------------------
#     def get_students(self, username):
#         self.cursor.execute("""
#             SELECT * FROM students
#             WHERE username = %s
#             ORDER BY createdAt ASC
#         """, (username,))
#         return self.cursor.fetchall()

#     # -------------------------------------------------
#     # Search
#     # -------------------------------------------------
#     def search_students(self, username, search):
#         like = f"%{search}%"
#         self.cursor.execute("""
#             SELECT * FROM students
#             WHERE username = %s AND (
#                 studID LIKE %s OR
#                 studFname LIKE %s OR
#                 studMname LIKE %s OR
#                 studLname LIKE %s
#             )
#             ORDER BY createdAt ASC
#         """, (username, like, like, like, like))
#         return self.cursor.fetchall()

#     # -------------------------------------------------
#     # Insert student
#     # -------------------------------------------------
#     def insert_student(self, username, data):
#         self.cursor.execute("""
#             INSERT INTO students(
#                 username,
#                 studID, studFname, studMname, studLname,
#                 studDOB, studSex,
#                 motherName, motherDOB,
#                 fatherName, fatherDOB,
#                 guardianName, guardianDOB,
#                 contact
#             )
#             VALUES (%(username)s, %(studID)s, %(studFname)s, %(studMname)s, %(studLname)s,
#                     %(studDOB)s, %(studSex)s,
#                     %(motherName)s, %(motherDOB)s,
#                     %(fatherName)s, %(fatherDOB)s,
#                     %(guardianName)s, %(guardianDOB)s,
#                     %(contact)s)
#         """, data)

#         self.conn.commit()
#         return True



# from database.connection import Database
# from psycopg2.extras import RealDictCursor


# class StudentController:
#     def __init__(self):
#         self.db = Database()
#         self.conn = self.db.connect()
#         self.cursor = self.conn.cursor(cursor_factory=RealDictCursor)

#     # -------------------------------------------------
#     # Generate Student Code using DB FUNCTION
#     # -------------------------------------------------
#     def generate_student_id(self, username):
#         self.cursor.execute("""
#             SELECT next_student_code(%s) AS code;
#         """, (username,))

#         row = self.cursor.fetchone()
#         return row["code"] if row else "S001"

#     # -------------------------------------------------
#     # Load all students for this user
#     # -------------------------------------------------
#     def get_students(self, username):
#         self.cursor.execute("""
#             SELECT *
#             FROM students
#             WHERE username = %s
#             ORDER BY createdat ASC;
#         """, (username,))
#         return self.cursor.fetchall()

#     # -------------------------------------------------
#     # Search students
#     # -------------------------------------------------
#     def search_students(self, username, term):
#         try:
#             sql = """
#                 SELECT 
#                     studid,
#                     studlname,
#                     studfname,
#                     studmname,
#                     studcontact
#                 FROM students
#                 WHERE LOWER(username) = LOWER(%s)
#                 AND (
#                         LOWER(studlname) LIKE LOWER(%s)
#                     OR  LOWER(studfname) LIKE LOWER(%s)
#                     OR  LOWER(studmname) LIKE LOWER(%s)
#                     OR  LOWER(studid) LIKE LOWER(%s)
#                 )
#                 ORDER BY studlname ASC, studfname ASC;
#             """

#             like_term = f"%{term}%"
#             self.cursor.execute(sql, (username, like_term, like_term, like_term, like_term))
#             rows = self.cursor.fetchall()

#             result = []
#             for r in rows:
#                 # IMPORTANT: use r["key"], NOT r("key")
#                 result.append({
#                     "studid": r["studid"],
#                     "studlname": r["studlname"],
#                     "studfname": r["studfname"],
#                     "studmname": r["studmname"],
#                     "studcontact": r["studcontact"]
#                 })

#             return result

#         except Exception as e:
#             print("Error in search_students:", e)
#             return []

#     # -------------------------------------------------
#     # Insert student (CALL PROCEDURE)
#     # -------------------------------------------------
#     def insert_student(self, username, data):
#         self.cursor.execute("""
#             CALL add_student(
#                 %(username)s,
#                 %(studID)s,
#                 %(studLname)s,
#                 %(studFname)s,
#                 %(studMname)s,
#                 %(studDOB)s,
#                 %(studSex)s,
#                 %(studContact)s,
#                 %(motherName)s,
#                 %(motherDOB)s,
#                 %(fatherName)s,
#                 %(fatherDOB)s,
#                 %(guardianName)s,
#                 %(guardianDOB)s
#             );
#         """, data)

#         self.conn.commit()
#         return True

#     def get_student(self, studID):
#         self.cursor.execute("""
#             SELECT *
#             FROM students
#             WHERE studID = %s
#             LIMIT 1;
#         """, (studID,))
#         return self.cursor.fetchone()


#     def update_student(self, data):
#         self.cursor.execute("""
#             CALL update_student(
#                 %(studID)s,
#                 %(studLname)s,
#                 %(studFname)s,
#                 %(studMname)s,
#                 %(studDOB)s,
#                 %(studSex)s,
#                 %(studContact)s,
#                 %(motherName)s,
#                 %(motherDOB)s,
#                 %(fatherName)s,
#                 %(fatherDOB)s,
#                 %(guardianName)s,
#                 %(guardianDOB)s
#             );
#         """, data)

#         self.conn.commit()
#         return True

    
#     def delete_student(self, studID):
#         self.cursor.execute("CALL delete_student(%s);", (studID,))
#         self.conn.commit()
#         return True



from database.connection import Database
from psycopg2.extras import RealDictCursor


class StudentController:
    def __init__(self):
        self.db = Database()
        self.conn = self.db.connect()
        self.cursor = self.conn.cursor(cursor_factory=RealDictCursor)

    # -------------------------------------------------
    # Generate Student Code using DB FUNCTION
    # -------------------------------------------------
    def generate_student_id(self, username):
        self.cursor.execute("""
            SELECT next_student_code(%s) AS code;
        """, (username,))
        row = self.cursor.fetchone()
        return row["code"] if row else "S001"

    # -------------------------------------------------
    # Load all students for this user
    # -------------------------------------------------
    def get_students(self, username):
        self.cursor.execute("""
            SELECT *
            FROM students
            WHERE username = %s
            ORDER BY createdat ASC;
        """, (username,))
        return self.cursor.fetchall()

    # -------------------------------------------------
    # Search students
    # -------------------------------------------------
    def search_students(self, username, term):
        try:
            sql = """
                SELECT 
                    studid,
                    studlname,
                    studfname,
                    studmname,
                    studcontact
                FROM students
                WHERE LOWER(username) = LOWER(%s)
                  AND (
                        LOWER(studlname) LIKE LOWER(%s)
                    OR  LOWER(studfname) LIKE LOWER(%s)
                    OR  LOWER(studmname) LIKE LOWER(%s)
                    OR  LOWER(studid) LIKE LOWER(%s)
                  )
                ORDER BY studlname ASC, studfname ASC;
            """

            like_term = f"%{term}%"
            self.cursor.execute(sql, (username, like_term, like_term, like_term, like_term))
            rows = self.cursor.fetchall()

            result = []
            for r in rows:
                result.append({
                    "studid": r["studid"],
                    "studlname": r["studlname"],
                    "studfname": r["studfname"],
                    "studmname": r["studmname"],
                    "studcontact": r["studcontact"],
                })

            return result

        except Exception as e:
            print("Error in search_students:", e)
            return []

    # -------------------------------------------------
    # Insert student (CALL PROCEDURE)
    # data must contain 'username' etc.
    # -------------------------------------------------
    def insert_student(self, data):
        self.cursor.execute("""
            CALL add_student(
                %(username)s,
                %(studID)s,
                %(studLname)s,
                %(studFname)s,
                %(studMname)s,
                %(studDOB)s,
                %(studSex)s,
                %(studContact)s,
                %(motherName)s,
                %(motherDOB)s,
                %(fatherName)s,
                %(fatherDOB)s,
                %(guardianName)s,
                %(guardianDOB)s
            );
        """, data)
        self.conn.commit()
        return True

    # -------------------------------------------------
    # Get single student by username + studID (code)
    # -------------------------------------------------
    def get_student(self, username, studID):
        self.cursor.execute("""
            SELECT *
            FROM students
            WHERE username = %s
              AND studid = %s
            LIMIT 1;
        """, (username, studID))
        return self.cursor.fetchone()

    # -------------------------------------------------
    # Update student (CALL PROCEDURE)
    # data must contain 'username' and 'studID'
    # -------------------------------------------------
    def update_student(self, data):
        self.cursor.execute("""
            CALL update_student(
                %(username)s,
                %(studID)s,
                %(studLname)s,
                %(studFname)s,
                %(studMname)s,
                %(studDOB)s,
                %(studSex)s,
                %(studContact)s,
                %(motherName)s,
                %(motherDOB)s,
                %(fatherName)s,
                %(fatherDOB)s,
                %(guardianName)s,
                %(guardianDOB)s
            );
        """, data)
        self.conn.commit()
        return True

    # -------------------------------------------------
    # Delete student (per user)
    # -------------------------------------------------
    def delete_student(self, username, studID):
        self.cursor.execute("""
            CALL delete_student(%s, %s);
        """, (username, studID))
        self.conn.commit()
        return True
